// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"anime-skip.com/backend/internal/graphql/models"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Account() AccountResolver
	Episode() EpisodeResolver
	EpisodeUrl() EpisodeUrlResolver
	Mutation() MutationResolver
	Preferences() PreferencesResolver
	Query() QueryResolver
	Show() ShowResolver
	ShowAdmin() ShowAdminResolver
	ThirdPartyEpisode() ThirdPartyEpisodeResolver
	ThirdPartyTimestamp() ThirdPartyTimestampResolver
	Timestamp() TimestampResolver
	TimestampType() TimestampTypeResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Authorized  func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	HasRole     func(ctx context.Context, obj interface{}, next graphql.Resolver, role models.Role) (res interface{}, err error)
	IsShowAdmin func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Account struct {
		AdminOfShows  func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Email         func(childComplexity int) int
		EmailVerified func(childComplexity int) int
		ID            func(childComplexity int) int
		Preferences   func(childComplexity int) int
		ProfileURL    func(childComplexity int) int
		Role          func(childComplexity int) int
		Username      func(childComplexity int) int
	}

	Episode struct {
		AbsoluteNumber  func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CreatedByUserID func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		DeletedBy       func(childComplexity int) int
		DeletedByUserID func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Number          func(childComplexity int) int
		Season          func(childComplexity int) int
		Show            func(childComplexity int) int
		ShowID          func(childComplexity int) int
		Timestamps      func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		UpdatedByUserID func(childComplexity int) int
		Urls            func(childComplexity int) int
	}

	EpisodeURL struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CreatedByUserID func(childComplexity int) int
		Episode         func(childComplexity int) int
		EpisodeID       func(childComplexity int) int
		Source          func(childComplexity int) int
		URL             func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		UpdatedByUserID func(childComplexity int) int
	}

	LoginData struct {
		Account      func(childComplexity int) int
		AuthToken    func(childComplexity int) int
		RefreshToken func(childComplexity int) int
	}

	Mutation struct {
		CreateAccount           func(childComplexity int, username string, email string, passwordHash string, recaptchaResponse string) int
		CreateEpisode           func(childComplexity int, showID string, episodeInput models.InputEpisode) int
		CreateEpisodeURL        func(childComplexity int, episodeID string, episodeURLInput models.InputEpisodeURL) int
		CreateShow              func(childComplexity int, showInput models.InputShow, becomeAdmin bool) int
		CreateShowAdmin         func(childComplexity int, showAdminInput models.InputShowAdmin) int
		CreateTimestamp         func(childComplexity int, episodeID string, timestampInput models.InputTimestamp) int
		CreateTimestampType     func(childComplexity int, timestampTypeInput models.InputTimestampType) int
		DeleteAccount           func(childComplexity int, deleteToken string) int
		DeleteAccountRequest    func(childComplexity int, passwordHash string) int
		DeleteEpisode           func(childComplexity int, episodeID string) int
		DeleteEpisodeURL        func(childComplexity int, episodeURL string) int
		DeleteShow              func(childComplexity int, showID string) int
		DeleteShowAdmin         func(childComplexity int, showAdminID string) int
		DeleteTimestamp         func(childComplexity int, timestampID string) int
		DeleteTimestampType     func(childComplexity int, timestampTypeID string) int
		ResendVerificationEmail func(childComplexity int) int
		SavePreferences         func(childComplexity int, preferences models.InputPreferences) int
		UpdateEpisode           func(childComplexity int, episodeID string, newEpisode models.InputEpisode) int
		UpdateShow              func(childComplexity int, showID string, newShow models.InputShow) int
		UpdateTimestamp         func(childComplexity int, timestampID string, newTimestamp models.InputTimestamp) int
		UpdateTimestampType     func(childComplexity int, timestampTypeID string, newTimestampType models.InputTimestampType) int
		VerifyEmailAddress      func(childComplexity int, validationToken string) int
	}

	Preferences struct {
		CreatedAt        func(childComplexity int) int
		DeletedAt        func(childComplexity int) int
		EnableAutoPlay   func(childComplexity int) int
		EnableAutoSkip   func(childComplexity int) int
		ID               func(childComplexity int) int
		SkipBranding     func(childComplexity int) int
		SkipCanon        func(childComplexity int) int
		SkipCredits      func(childComplexity int) int
		SkipFiller       func(childComplexity int) int
		SkipIntros       func(childComplexity int) int
		SkipMixedCredits func(childComplexity int) int
		SkipMixedIntros  func(childComplexity int) int
		SkipNewCredits   func(childComplexity int) int
		SkipNewIntros    func(childComplexity int) int
		SkipPreview      func(childComplexity int) int
		SkipRecaps       func(childComplexity int) int
		SkipTitleCard    func(childComplexity int) int
		SkipTransitions  func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		User             func(childComplexity int) int
		UserID           func(childComplexity int) int
	}

	Query struct {
		Account                    func(childComplexity int) int
		AllTimestampTypes          func(childComplexity int) int
		FindEpisode                func(childComplexity int, episodeID string) int
		FindEpisodeByName          func(childComplexity int, name string) int
		FindEpisodeURL             func(childComplexity int, episodeURL string) int
		FindEpisodeUrlsByEpisodeID func(childComplexity int, episodeID string) int
		FindEpisodesByShowID       func(childComplexity int, showID string) int
		FindShow                   func(childComplexity int, showID string) int
		FindShowAdmin              func(childComplexity int, showAdminID string) int
		FindShowAdminsByShowID     func(childComplexity int, showID string) int
		FindShowAdminsByUserID     func(childComplexity int, userID string) int
		FindTimestamp              func(childComplexity int, timestampID string) int
		FindTimestampType          func(childComplexity int, timestampTypeID string) int
		FindTimestampsByEpisodeID  func(childComplexity int, episodeID string) int
		FindUser                   func(childComplexity int, userID string) int
		FindUserByUsername         func(childComplexity int, username string) int
		Login                      func(childComplexity int, usernameEmail string, passwordHash string) int
		LoginRefresh               func(childComplexity int, refreshToken string) int
		SearchEpisodes             func(childComplexity int, search *string, showID *string, offset *int, limit *int, sort *string) int
		SearchShows                func(childComplexity int, search *string, offset *int, limit *int, sort *string) int
	}

	Show struct {
		Admins          func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CreatedByUserID func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		DeletedBy       func(childComplexity int) int
		DeletedByUserID func(childComplexity int) int
		Episodes        func(childComplexity int) int
		ID              func(childComplexity int) int
		Image           func(childComplexity int) int
		Name            func(childComplexity int) int
		OriginalName    func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		UpdatedByUserID func(childComplexity int) int
		Website         func(childComplexity int) int
	}

	ShowAdmin struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CreatedByUserID func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		DeletedBy       func(childComplexity int) int
		DeletedByUserID func(childComplexity int) int
		ID              func(childComplexity int) int
		Show            func(childComplexity int) int
		ShowID          func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		UpdatedByUserID func(childComplexity int) int
		User            func(childComplexity int) int
		UserID          func(childComplexity int) int
	}

	ThirdPartyEpisode struct {
		AbsoluteNumber func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
		Number         func(childComplexity int) int
		Season         func(childComplexity int) int
		Source         func(childComplexity int) int
		Timestamps     func(childComplexity int) int
	}

	ThirdPartyTimestamp struct {
		At     func(childComplexity int) int
		ID     func(childComplexity int) int
		Type   func(childComplexity int) int
		TypeID func(childComplexity int) int
	}

	Timestamp struct {
		At              func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CreatedByUserID func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		DeletedBy       func(childComplexity int) int
		DeletedByUserID func(childComplexity int) int
		Episode         func(childComplexity int) int
		EpisodeID       func(childComplexity int) int
		ID              func(childComplexity int) int
		Source          func(childComplexity int) int
		Type            func(childComplexity int) int
		TypeID          func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		UpdatedByUserID func(childComplexity int) int
	}

	TimestampType struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		CreatedByUserID func(childComplexity int) int
		DeletedAt       func(childComplexity int) int
		DeletedBy       func(childComplexity int) int
		DeletedByUserID func(childComplexity int) int
		Description     func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		UpdatedBy       func(childComplexity int) int
		UpdatedByUserID func(childComplexity int) int
	}

	User struct {
		AdminOfShows func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProfileURL   func(childComplexity int) int
		Username     func(childComplexity int) int
	}
}

type AccountResolver interface {
	AdminOfShows(ctx context.Context, obj *models.Account) ([]*models.ShowAdmin, error)

	Preferences(ctx context.Context, obj *models.Account) (*models.Preferences, error)
}
type EpisodeResolver interface {
	CreatedBy(ctx context.Context, obj *models.Episode) (*models.User, error)

	UpdatedBy(ctx context.Context, obj *models.Episode) (*models.User, error)

	DeletedBy(ctx context.Context, obj *models.Episode) (*models.User, error)

	Show(ctx context.Context, obj *models.Episode) (*models.Show, error)

	Timestamps(ctx context.Context, obj *models.Episode) ([]*models.Timestamp, error)
	Urls(ctx context.Context, obj *models.Episode) ([]*models.EpisodeURL, error)
}
type EpisodeUrlResolver interface {
	CreatedBy(ctx context.Context, obj *models.EpisodeURL) (*models.User, error)

	UpdatedBy(ctx context.Context, obj *models.EpisodeURL) (*models.User, error)

	Episode(ctx context.Context, obj *models.EpisodeURL) (*models.Episode, error)
}
type MutationResolver interface {
	CreateAccount(ctx context.Context, username string, email string, passwordHash string, recaptchaResponse string) (*models.LoginData, error)
	ResendVerificationEmail(ctx context.Context) (*bool, error)
	VerifyEmailAddress(ctx context.Context, validationToken string) (*models.Account, error)
	DeleteAccountRequest(ctx context.Context, passwordHash string) (*models.Account, error)
	DeleteAccount(ctx context.Context, deleteToken string) (*models.Account, error)
	SavePreferences(ctx context.Context, preferences models.InputPreferences) (*models.Preferences, error)
	CreateShow(ctx context.Context, showInput models.InputShow, becomeAdmin bool) (*models.Show, error)
	UpdateShow(ctx context.Context, showID string, newShow models.InputShow) (*models.Show, error)
	DeleteShow(ctx context.Context, showID string) (*models.Show, error)
	CreateShowAdmin(ctx context.Context, showAdminInput models.InputShowAdmin) (*models.ShowAdmin, error)
	DeleteShowAdmin(ctx context.Context, showAdminID string) (*models.ShowAdmin, error)
	CreateEpisode(ctx context.Context, showID string, episodeInput models.InputEpisode) (*models.Episode, error)
	UpdateEpisode(ctx context.Context, episodeID string, newEpisode models.InputEpisode) (*models.Episode, error)
	DeleteEpisode(ctx context.Context, episodeID string) (*models.Episode, error)
	CreateEpisodeURL(ctx context.Context, episodeID string, episodeURLInput models.InputEpisodeURL) (*models.EpisodeURL, error)
	DeleteEpisodeURL(ctx context.Context, episodeURL string) (*models.EpisodeURL, error)
	CreateTimestamp(ctx context.Context, episodeID string, timestampInput models.InputTimestamp) (*models.Timestamp, error)
	UpdateTimestamp(ctx context.Context, timestampID string, newTimestamp models.InputTimestamp) (*models.Timestamp, error)
	DeleteTimestamp(ctx context.Context, timestampID string) (*models.Timestamp, error)
	CreateTimestampType(ctx context.Context, timestampTypeInput models.InputTimestampType) (*models.TimestampType, error)
	UpdateTimestampType(ctx context.Context, timestampTypeID string, newTimestampType models.InputTimestampType) (*models.TimestampType, error)
	DeleteTimestampType(ctx context.Context, timestampTypeID string) (*models.TimestampType, error)
}
type PreferencesResolver interface {
	User(ctx context.Context, obj *models.Preferences) (*models.User, error)
}
type QueryResolver interface {
	Account(ctx context.Context) (*models.Account, error)
	Login(ctx context.Context, usernameEmail string, passwordHash string) (*models.LoginData, error)
	LoginRefresh(ctx context.Context, refreshToken string) (*models.LoginData, error)
	FindUser(ctx context.Context, userID string) (*models.User, error)
	FindUserByUsername(ctx context.Context, username string) (*models.User, error)
	FindShow(ctx context.Context, showID string) (*models.Show, error)
	SearchShows(ctx context.Context, search *string, offset *int, limit *int, sort *string) ([]*models.Show, error)
	FindShowAdmin(ctx context.Context, showAdminID string) (*models.ShowAdmin, error)
	FindShowAdminsByShowID(ctx context.Context, showID string) ([]*models.ShowAdmin, error)
	FindShowAdminsByUserID(ctx context.Context, userID string) ([]*models.ShowAdmin, error)
	FindEpisode(ctx context.Context, episodeID string) (*models.Episode, error)
	FindEpisodesByShowID(ctx context.Context, showID string) ([]*models.Episode, error)
	SearchEpisodes(ctx context.Context, search *string, showID *string, offset *int, limit *int, sort *string) ([]*models.Episode, error)
	FindEpisodeByName(ctx context.Context, name string) ([]*models.ThirdPartyEpisode, error)
	FindEpisodeURL(ctx context.Context, episodeURL string) (*models.EpisodeURL, error)
	FindEpisodeUrlsByEpisodeID(ctx context.Context, episodeID string) ([]*models.EpisodeURL, error)
	FindTimestamp(ctx context.Context, timestampID string) (*models.Timestamp, error)
	FindTimestampsByEpisodeID(ctx context.Context, episodeID string) ([]*models.Timestamp, error)
	FindTimestampType(ctx context.Context, timestampTypeID string) (*models.TimestampType, error)
	AllTimestampTypes(ctx context.Context) ([]*models.TimestampType, error)
}
type ShowResolver interface {
	CreatedBy(ctx context.Context, obj *models.Show) (*models.User, error)

	UpdatedBy(ctx context.Context, obj *models.Show) (*models.User, error)

	DeletedBy(ctx context.Context, obj *models.Show) (*models.User, error)

	Admins(ctx context.Context, obj *models.Show) ([]*models.ShowAdmin, error)
	Episodes(ctx context.Context, obj *models.Show) ([]*models.Episode, error)
}
type ShowAdminResolver interface {
	CreatedBy(ctx context.Context, obj *models.ShowAdmin) (*models.User, error)

	UpdatedBy(ctx context.Context, obj *models.ShowAdmin) (*models.User, error)

	DeletedBy(ctx context.Context, obj *models.ShowAdmin) (*models.User, error)

	Show(ctx context.Context, obj *models.ShowAdmin) (*models.Show, error)

	User(ctx context.Context, obj *models.ShowAdmin) (*models.User, error)
}
type ThirdPartyEpisodeResolver interface {
	Timestamps(ctx context.Context, obj *models.ThirdPartyEpisode) ([]*models.ThirdPartyTimestamp, error)
}
type ThirdPartyTimestampResolver interface {
	Type(ctx context.Context, obj *models.ThirdPartyTimestamp) (*models.TimestampType, error)
}
type TimestampResolver interface {
	CreatedBy(ctx context.Context, obj *models.Timestamp) (*models.User, error)

	UpdatedBy(ctx context.Context, obj *models.Timestamp) (*models.User, error)

	DeletedBy(ctx context.Context, obj *models.Timestamp) (*models.User, error)

	Type(ctx context.Context, obj *models.Timestamp) (*models.TimestampType, error)

	Episode(ctx context.Context, obj *models.Timestamp) (*models.Episode, error)
}
type TimestampTypeResolver interface {
	CreatedBy(ctx context.Context, obj *models.TimestampType) (*models.User, error)

	UpdatedBy(ctx context.Context, obj *models.TimestampType) (*models.User, error)

	DeletedBy(ctx context.Context, obj *models.TimestampType) (*models.User, error)
}
type UserResolver interface {
	AdminOfShows(ctx context.Context, obj *models.User) ([]*models.ShowAdmin, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.adminOfShows":
		if e.complexity.Account.AdminOfShows == nil {
			break
		}

		return e.complexity.Account.AdminOfShows(childComplexity), true

	case "Account.createdAt":
		if e.complexity.Account.CreatedAt == nil {
			break
		}

		return e.complexity.Account.CreatedAt(childComplexity), true

	case "Account.deletedAt":
		if e.complexity.Account.DeletedAt == nil {
			break
		}

		return e.complexity.Account.DeletedAt(childComplexity), true

	case "Account.email":
		if e.complexity.Account.Email == nil {
			break
		}

		return e.complexity.Account.Email(childComplexity), true

	case "Account.emailVerified":
		if e.complexity.Account.EmailVerified == nil {
			break
		}

		return e.complexity.Account.EmailVerified(childComplexity), true

	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true

	case "Account.preferences":
		if e.complexity.Account.Preferences == nil {
			break
		}

		return e.complexity.Account.Preferences(childComplexity), true

	case "Account.profileUrl":
		if e.complexity.Account.ProfileURL == nil {
			break
		}

		return e.complexity.Account.ProfileURL(childComplexity), true

	case "Account.role":
		if e.complexity.Account.Role == nil {
			break
		}

		return e.complexity.Account.Role(childComplexity), true

	case "Account.username":
		if e.complexity.Account.Username == nil {
			break
		}

		return e.complexity.Account.Username(childComplexity), true

	case "Episode.absoluteNumber":
		if e.complexity.Episode.AbsoluteNumber == nil {
			break
		}

		return e.complexity.Episode.AbsoluteNumber(childComplexity), true

	case "Episode.createdAt":
		if e.complexity.Episode.CreatedAt == nil {
			break
		}

		return e.complexity.Episode.CreatedAt(childComplexity), true

	case "Episode.createdBy":
		if e.complexity.Episode.CreatedBy == nil {
			break
		}

		return e.complexity.Episode.CreatedBy(childComplexity), true

	case "Episode.createdByUserId":
		if e.complexity.Episode.CreatedByUserID == nil {
			break
		}

		return e.complexity.Episode.CreatedByUserID(childComplexity), true

	case "Episode.deletedAt":
		if e.complexity.Episode.DeletedAt == nil {
			break
		}

		return e.complexity.Episode.DeletedAt(childComplexity), true

	case "Episode.deletedBy":
		if e.complexity.Episode.DeletedBy == nil {
			break
		}

		return e.complexity.Episode.DeletedBy(childComplexity), true

	case "Episode.deletedByUserId":
		if e.complexity.Episode.DeletedByUserID == nil {
			break
		}

		return e.complexity.Episode.DeletedByUserID(childComplexity), true

	case "Episode.id":
		if e.complexity.Episode.ID == nil {
			break
		}

		return e.complexity.Episode.ID(childComplexity), true

	case "Episode.name":
		if e.complexity.Episode.Name == nil {
			break
		}

		return e.complexity.Episode.Name(childComplexity), true

	case "Episode.number":
		if e.complexity.Episode.Number == nil {
			break
		}

		return e.complexity.Episode.Number(childComplexity), true

	case "Episode.season":
		if e.complexity.Episode.Season == nil {
			break
		}

		return e.complexity.Episode.Season(childComplexity), true

	case "Episode.show":
		if e.complexity.Episode.Show == nil {
			break
		}

		return e.complexity.Episode.Show(childComplexity), true

	case "Episode.showId":
		if e.complexity.Episode.ShowID == nil {
			break
		}

		return e.complexity.Episode.ShowID(childComplexity), true

	case "Episode.timestamps":
		if e.complexity.Episode.Timestamps == nil {
			break
		}

		return e.complexity.Episode.Timestamps(childComplexity), true

	case "Episode.updatedAt":
		if e.complexity.Episode.UpdatedAt == nil {
			break
		}

		return e.complexity.Episode.UpdatedAt(childComplexity), true

	case "Episode.updatedBy":
		if e.complexity.Episode.UpdatedBy == nil {
			break
		}

		return e.complexity.Episode.UpdatedBy(childComplexity), true

	case "Episode.updatedByUserId":
		if e.complexity.Episode.UpdatedByUserID == nil {
			break
		}

		return e.complexity.Episode.UpdatedByUserID(childComplexity), true

	case "Episode.urls":
		if e.complexity.Episode.Urls == nil {
			break
		}

		return e.complexity.Episode.Urls(childComplexity), true

	case "EpisodeUrl.createdAt":
		if e.complexity.EpisodeURL.CreatedAt == nil {
			break
		}

		return e.complexity.EpisodeURL.CreatedAt(childComplexity), true

	case "EpisodeUrl.createdBy":
		if e.complexity.EpisodeURL.CreatedBy == nil {
			break
		}

		return e.complexity.EpisodeURL.CreatedBy(childComplexity), true

	case "EpisodeUrl.createdByUserId":
		if e.complexity.EpisodeURL.CreatedByUserID == nil {
			break
		}

		return e.complexity.EpisodeURL.CreatedByUserID(childComplexity), true

	case "EpisodeUrl.episode":
		if e.complexity.EpisodeURL.Episode == nil {
			break
		}

		return e.complexity.EpisodeURL.Episode(childComplexity), true

	case "EpisodeUrl.episodeId":
		if e.complexity.EpisodeURL.EpisodeID == nil {
			break
		}

		return e.complexity.EpisodeURL.EpisodeID(childComplexity), true

	case "EpisodeUrl.source":
		if e.complexity.EpisodeURL.Source == nil {
			break
		}

		return e.complexity.EpisodeURL.Source(childComplexity), true

	case "EpisodeUrl.url":
		if e.complexity.EpisodeURL.URL == nil {
			break
		}

		return e.complexity.EpisodeURL.URL(childComplexity), true

	case "EpisodeUrl.updatedAt":
		if e.complexity.EpisodeURL.UpdatedAt == nil {
			break
		}

		return e.complexity.EpisodeURL.UpdatedAt(childComplexity), true

	case "EpisodeUrl.updatedBy":
		if e.complexity.EpisodeURL.UpdatedBy == nil {
			break
		}

		return e.complexity.EpisodeURL.UpdatedBy(childComplexity), true

	case "EpisodeUrl.updatedByUserId":
		if e.complexity.EpisodeURL.UpdatedByUserID == nil {
			break
		}

		return e.complexity.EpisodeURL.UpdatedByUserID(childComplexity), true

	case "LoginData.account":
		if e.complexity.LoginData.Account == nil {
			break
		}

		return e.complexity.LoginData.Account(childComplexity), true

	case "LoginData.authToken":
		if e.complexity.LoginData.AuthToken == nil {
			break
		}

		return e.complexity.LoginData.AuthToken(childComplexity), true

	case "LoginData.refreshToken":
		if e.complexity.LoginData.RefreshToken == nil {
			break
		}

		return e.complexity.LoginData.RefreshToken(childComplexity), true

	case "Mutation.createAccount":
		if e.complexity.Mutation.CreateAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAccount(childComplexity, args["username"].(string), args["email"].(string), args["passwordHash"].(string), args["recaptchaResponse"].(string)), true

	case "Mutation.createEpisode":
		if e.complexity.Mutation.CreateEpisode == nil {
			break
		}

		args, err := ec.field_Mutation_createEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEpisode(childComplexity, args["showId"].(string), args["episodeInput"].(models.InputEpisode)), true

	case "Mutation.createEpisodeUrl":
		if e.complexity.Mutation.CreateEpisodeURL == nil {
			break
		}

		args, err := ec.field_Mutation_createEpisodeUrl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEpisodeURL(childComplexity, args["episodeId"].(string), args["episodeUrlInput"].(models.InputEpisodeURL)), true

	case "Mutation.createShow":
		if e.complexity.Mutation.CreateShow == nil {
			break
		}

		args, err := ec.field_Mutation_createShow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateShow(childComplexity, args["showInput"].(models.InputShow), args["becomeAdmin"].(bool)), true

	case "Mutation.createShowAdmin":
		if e.complexity.Mutation.CreateShowAdmin == nil {
			break
		}

		args, err := ec.field_Mutation_createShowAdmin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateShowAdmin(childComplexity, args["showAdminInput"].(models.InputShowAdmin)), true

	case "Mutation.createTimestamp":
		if e.complexity.Mutation.CreateTimestamp == nil {
			break
		}

		args, err := ec.field_Mutation_createTimestamp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTimestamp(childComplexity, args["episodeId"].(string), args["timestampInput"].(models.InputTimestamp)), true

	case "Mutation.createTimestampType":
		if e.complexity.Mutation.CreateTimestampType == nil {
			break
		}

		args, err := ec.field_Mutation_createTimestampType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTimestampType(childComplexity, args["timestampTypeInput"].(models.InputTimestampType)), true

	case "Mutation.deleteAccount":
		if e.complexity.Mutation.DeleteAccount == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAccount(childComplexity, args["deleteToken"].(string)), true

	case "Mutation.deleteAccountRequest":
		if e.complexity.Mutation.DeleteAccountRequest == nil {
			break
		}

		args, err := ec.field_Mutation_deleteAccountRequest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAccountRequest(childComplexity, args["passwordHash"].(string)), true

	case "Mutation.deleteEpisode":
		if e.complexity.Mutation.DeleteEpisode == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEpisode(childComplexity, args["episodeId"].(string)), true

	case "Mutation.deleteEpisodeUrl":
		if e.complexity.Mutation.DeleteEpisodeURL == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEpisodeUrl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEpisodeURL(childComplexity, args["episodeUrl"].(string)), true

	case "Mutation.deleteShow":
		if e.complexity.Mutation.DeleteShow == nil {
			break
		}

		args, err := ec.field_Mutation_deleteShow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteShow(childComplexity, args["showId"].(string)), true

	case "Mutation.deleteShowAdmin":
		if e.complexity.Mutation.DeleteShowAdmin == nil {
			break
		}

		args, err := ec.field_Mutation_deleteShowAdmin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteShowAdmin(childComplexity, args["showAdminId"].(string)), true

	case "Mutation.deleteTimestamp":
		if e.complexity.Mutation.DeleteTimestamp == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTimestamp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTimestamp(childComplexity, args["timestampId"].(string)), true

	case "Mutation.deleteTimestampType":
		if e.complexity.Mutation.DeleteTimestampType == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTimestampType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTimestampType(childComplexity, args["timestampTypeId"].(string)), true

	case "Mutation.resendVerificationEmail":
		if e.complexity.Mutation.ResendVerificationEmail == nil {
			break
		}

		return e.complexity.Mutation.ResendVerificationEmail(childComplexity), true

	case "Mutation.savePreferences":
		if e.complexity.Mutation.SavePreferences == nil {
			break
		}

		args, err := ec.field_Mutation_savePreferences_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SavePreferences(childComplexity, args["preferences"].(models.InputPreferences)), true

	case "Mutation.updateEpisode":
		if e.complexity.Mutation.UpdateEpisode == nil {
			break
		}

		args, err := ec.field_Mutation_updateEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEpisode(childComplexity, args["episodeId"].(string), args["newEpisode"].(models.InputEpisode)), true

	case "Mutation.updateShow":
		if e.complexity.Mutation.UpdateShow == nil {
			break
		}

		args, err := ec.field_Mutation_updateShow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateShow(childComplexity, args["showId"].(string), args["newShow"].(models.InputShow)), true

	case "Mutation.updateTimestamp":
		if e.complexity.Mutation.UpdateTimestamp == nil {
			break
		}

		args, err := ec.field_Mutation_updateTimestamp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTimestamp(childComplexity, args["timestampId"].(string), args["newTimestamp"].(models.InputTimestamp)), true

	case "Mutation.updateTimestampType":
		if e.complexity.Mutation.UpdateTimestampType == nil {
			break
		}

		args, err := ec.field_Mutation_updateTimestampType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTimestampType(childComplexity, args["timestampTypeId"].(string), args["newTimestampType"].(models.InputTimestampType)), true

	case "Mutation.verifyEmailAddress":
		if e.complexity.Mutation.VerifyEmailAddress == nil {
			break
		}

		args, err := ec.field_Mutation_verifyEmailAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyEmailAddress(childComplexity, args["validationToken"].(string)), true

	case "Preferences.createdAt":
		if e.complexity.Preferences.CreatedAt == nil {
			break
		}

		return e.complexity.Preferences.CreatedAt(childComplexity), true

	case "Preferences.deletedAt":
		if e.complexity.Preferences.DeletedAt == nil {
			break
		}

		return e.complexity.Preferences.DeletedAt(childComplexity), true

	case "Preferences.enableAutoPlay":
		if e.complexity.Preferences.EnableAutoPlay == nil {
			break
		}

		return e.complexity.Preferences.EnableAutoPlay(childComplexity), true

	case "Preferences.enableAutoSkip":
		if e.complexity.Preferences.EnableAutoSkip == nil {
			break
		}

		return e.complexity.Preferences.EnableAutoSkip(childComplexity), true

	case "Preferences.id":
		if e.complexity.Preferences.ID == nil {
			break
		}

		return e.complexity.Preferences.ID(childComplexity), true

	case "Preferences.skipBranding":
		if e.complexity.Preferences.SkipBranding == nil {
			break
		}

		return e.complexity.Preferences.SkipBranding(childComplexity), true

	case "Preferences.skipCanon":
		if e.complexity.Preferences.SkipCanon == nil {
			break
		}

		return e.complexity.Preferences.SkipCanon(childComplexity), true

	case "Preferences.skipCredits":
		if e.complexity.Preferences.SkipCredits == nil {
			break
		}

		return e.complexity.Preferences.SkipCredits(childComplexity), true

	case "Preferences.skipFiller":
		if e.complexity.Preferences.SkipFiller == nil {
			break
		}

		return e.complexity.Preferences.SkipFiller(childComplexity), true

	case "Preferences.skipIntros":
		if e.complexity.Preferences.SkipIntros == nil {
			break
		}

		return e.complexity.Preferences.SkipIntros(childComplexity), true

	case "Preferences.skipMixedCredits":
		if e.complexity.Preferences.SkipMixedCredits == nil {
			break
		}

		return e.complexity.Preferences.SkipMixedCredits(childComplexity), true

	case "Preferences.skipMixedIntros":
		if e.complexity.Preferences.SkipMixedIntros == nil {
			break
		}

		return e.complexity.Preferences.SkipMixedIntros(childComplexity), true

	case "Preferences.skipNewCredits":
		if e.complexity.Preferences.SkipNewCredits == nil {
			break
		}

		return e.complexity.Preferences.SkipNewCredits(childComplexity), true

	case "Preferences.skipNewIntros":
		if e.complexity.Preferences.SkipNewIntros == nil {
			break
		}

		return e.complexity.Preferences.SkipNewIntros(childComplexity), true

	case "Preferences.skipPreview":
		if e.complexity.Preferences.SkipPreview == nil {
			break
		}

		return e.complexity.Preferences.SkipPreview(childComplexity), true

	case "Preferences.skipRecaps":
		if e.complexity.Preferences.SkipRecaps == nil {
			break
		}

		return e.complexity.Preferences.SkipRecaps(childComplexity), true

	case "Preferences.skipTitleCard":
		if e.complexity.Preferences.SkipTitleCard == nil {
			break
		}

		return e.complexity.Preferences.SkipTitleCard(childComplexity), true

	case "Preferences.skipTransitions":
		if e.complexity.Preferences.SkipTransitions == nil {
			break
		}

		return e.complexity.Preferences.SkipTransitions(childComplexity), true

	case "Preferences.updatedAt":
		if e.complexity.Preferences.UpdatedAt == nil {
			break
		}

		return e.complexity.Preferences.UpdatedAt(childComplexity), true

	case "Preferences.user":
		if e.complexity.Preferences.User == nil {
			break
		}

		return e.complexity.Preferences.User(childComplexity), true

	case "Preferences.userId":
		if e.complexity.Preferences.UserID == nil {
			break
		}

		return e.complexity.Preferences.UserID(childComplexity), true

	case "Query.account":
		if e.complexity.Query.Account == nil {
			break
		}

		return e.complexity.Query.Account(childComplexity), true

	case "Query.allTimestampTypes":
		if e.complexity.Query.AllTimestampTypes == nil {
			break
		}

		return e.complexity.Query.AllTimestampTypes(childComplexity), true

	case "Query.findEpisode":
		if e.complexity.Query.FindEpisode == nil {
			break
		}

		args, err := ec.field_Query_findEpisode_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindEpisode(childComplexity, args["episodeId"].(string)), true

	case "Query.findEpisodeByName":
		if e.complexity.Query.FindEpisodeByName == nil {
			break
		}

		args, err := ec.field_Query_findEpisodeByName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindEpisodeByName(childComplexity, args["name"].(string)), true

	case "Query.findEpisodeUrl":
		if e.complexity.Query.FindEpisodeURL == nil {
			break
		}

		args, err := ec.field_Query_findEpisodeUrl_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindEpisodeURL(childComplexity, args["episodeUrl"].(string)), true

	case "Query.findEpisodeUrlsByEpisodeId":
		if e.complexity.Query.FindEpisodeUrlsByEpisodeID == nil {
			break
		}

		args, err := ec.field_Query_findEpisodeUrlsByEpisodeId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindEpisodeUrlsByEpisodeID(childComplexity, args["episodeId"].(string)), true

	case "Query.findEpisodesByShowId":
		if e.complexity.Query.FindEpisodesByShowID == nil {
			break
		}

		args, err := ec.field_Query_findEpisodesByShowId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindEpisodesByShowID(childComplexity, args["showId"].(string)), true

	case "Query.findShow":
		if e.complexity.Query.FindShow == nil {
			break
		}

		args, err := ec.field_Query_findShow_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindShow(childComplexity, args["showId"].(string)), true

	case "Query.findShowAdmin":
		if e.complexity.Query.FindShowAdmin == nil {
			break
		}

		args, err := ec.field_Query_findShowAdmin_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindShowAdmin(childComplexity, args["showAdminId"].(string)), true

	case "Query.findShowAdminsByShowId":
		if e.complexity.Query.FindShowAdminsByShowID == nil {
			break
		}

		args, err := ec.field_Query_findShowAdminsByShowId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindShowAdminsByShowID(childComplexity, args["showId"].(string)), true

	case "Query.findShowAdminsByUserId":
		if e.complexity.Query.FindShowAdminsByUserID == nil {
			break
		}

		args, err := ec.field_Query_findShowAdminsByUserId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindShowAdminsByUserID(childComplexity, args["userId"].(string)), true

	case "Query.findTimestamp":
		if e.complexity.Query.FindTimestamp == nil {
			break
		}

		args, err := ec.field_Query_findTimestamp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTimestamp(childComplexity, args["timestampId"].(string)), true

	case "Query.findTimestampType":
		if e.complexity.Query.FindTimestampType == nil {
			break
		}

		args, err := ec.field_Query_findTimestampType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTimestampType(childComplexity, args["timestampTypeId"].(string)), true

	case "Query.findTimestampsByEpisodeId":
		if e.complexity.Query.FindTimestampsByEpisodeID == nil {
			break
		}

		args, err := ec.field_Query_findTimestampsByEpisodeId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTimestampsByEpisodeID(childComplexity, args["episodeId"].(string)), true

	case "Query.findUser":
		if e.complexity.Query.FindUser == nil {
			break
		}

		args, err := ec.field_Query_findUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUser(childComplexity, args["userId"].(string)), true

	case "Query.findUserByUsername":
		if e.complexity.Query.FindUserByUsername == nil {
			break
		}

		args, err := ec.field_Query_findUserByUsername_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUserByUsername(childComplexity, args["username"].(string)), true

	case "Query.login":
		if e.complexity.Query.Login == nil {
			break
		}

		args, err := ec.field_Query_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Login(childComplexity, args["usernameEmail"].(string), args["passwordHash"].(string)), true

	case "Query.loginRefresh":
		if e.complexity.Query.LoginRefresh == nil {
			break
		}

		args, err := ec.field_Query_loginRefresh_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LoginRefresh(childComplexity, args["refreshToken"].(string)), true

	case "Query.searchEpisodes":
		if e.complexity.Query.SearchEpisodes == nil {
			break
		}

		args, err := ec.field_Query_searchEpisodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchEpisodes(childComplexity, args["search"].(*string), args["showId"].(*string), args["offset"].(*int), args["limit"].(*int), args["sort"].(*string)), true

	case "Query.searchShows":
		if e.complexity.Query.SearchShows == nil {
			break
		}

		args, err := ec.field_Query_searchShows_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchShows(childComplexity, args["search"].(*string), args["offset"].(*int), args["limit"].(*int), args["sort"].(*string)), true

	case "Show.admins":
		if e.complexity.Show.Admins == nil {
			break
		}

		return e.complexity.Show.Admins(childComplexity), true

	case "Show.createdAt":
		if e.complexity.Show.CreatedAt == nil {
			break
		}

		return e.complexity.Show.CreatedAt(childComplexity), true

	case "Show.createdBy":
		if e.complexity.Show.CreatedBy == nil {
			break
		}

		return e.complexity.Show.CreatedBy(childComplexity), true

	case "Show.createdByUserId":
		if e.complexity.Show.CreatedByUserID == nil {
			break
		}

		return e.complexity.Show.CreatedByUserID(childComplexity), true

	case "Show.deletedAt":
		if e.complexity.Show.DeletedAt == nil {
			break
		}

		return e.complexity.Show.DeletedAt(childComplexity), true

	case "Show.deletedBy":
		if e.complexity.Show.DeletedBy == nil {
			break
		}

		return e.complexity.Show.DeletedBy(childComplexity), true

	case "Show.deletedByUserId":
		if e.complexity.Show.DeletedByUserID == nil {
			break
		}

		return e.complexity.Show.DeletedByUserID(childComplexity), true

	case "Show.episodes":
		if e.complexity.Show.Episodes == nil {
			break
		}

		return e.complexity.Show.Episodes(childComplexity), true

	case "Show.id":
		if e.complexity.Show.ID == nil {
			break
		}

		return e.complexity.Show.ID(childComplexity), true

	case "Show.image":
		if e.complexity.Show.Image == nil {
			break
		}

		return e.complexity.Show.Image(childComplexity), true

	case "Show.name":
		if e.complexity.Show.Name == nil {
			break
		}

		return e.complexity.Show.Name(childComplexity), true

	case "Show.originalName":
		if e.complexity.Show.OriginalName == nil {
			break
		}

		return e.complexity.Show.OriginalName(childComplexity), true

	case "Show.updatedAt":
		if e.complexity.Show.UpdatedAt == nil {
			break
		}

		return e.complexity.Show.UpdatedAt(childComplexity), true

	case "Show.updatedBy":
		if e.complexity.Show.UpdatedBy == nil {
			break
		}

		return e.complexity.Show.UpdatedBy(childComplexity), true

	case "Show.updatedByUserId":
		if e.complexity.Show.UpdatedByUserID == nil {
			break
		}

		return e.complexity.Show.UpdatedByUserID(childComplexity), true

	case "Show.website":
		if e.complexity.Show.Website == nil {
			break
		}

		return e.complexity.Show.Website(childComplexity), true

	case "ShowAdmin.createdAt":
		if e.complexity.ShowAdmin.CreatedAt == nil {
			break
		}

		return e.complexity.ShowAdmin.CreatedAt(childComplexity), true

	case "ShowAdmin.createdBy":
		if e.complexity.ShowAdmin.CreatedBy == nil {
			break
		}

		return e.complexity.ShowAdmin.CreatedBy(childComplexity), true

	case "ShowAdmin.createdByUserId":
		if e.complexity.ShowAdmin.CreatedByUserID == nil {
			break
		}

		return e.complexity.ShowAdmin.CreatedByUserID(childComplexity), true

	case "ShowAdmin.deletedAt":
		if e.complexity.ShowAdmin.DeletedAt == nil {
			break
		}

		return e.complexity.ShowAdmin.DeletedAt(childComplexity), true

	case "ShowAdmin.deletedBy":
		if e.complexity.ShowAdmin.DeletedBy == nil {
			break
		}

		return e.complexity.ShowAdmin.DeletedBy(childComplexity), true

	case "ShowAdmin.deletedByUserId":
		if e.complexity.ShowAdmin.DeletedByUserID == nil {
			break
		}

		return e.complexity.ShowAdmin.DeletedByUserID(childComplexity), true

	case "ShowAdmin.id":
		if e.complexity.ShowAdmin.ID == nil {
			break
		}

		return e.complexity.ShowAdmin.ID(childComplexity), true

	case "ShowAdmin.show":
		if e.complexity.ShowAdmin.Show == nil {
			break
		}

		return e.complexity.ShowAdmin.Show(childComplexity), true

	case "ShowAdmin.showId":
		if e.complexity.ShowAdmin.ShowID == nil {
			break
		}

		return e.complexity.ShowAdmin.ShowID(childComplexity), true

	case "ShowAdmin.updatedAt":
		if e.complexity.ShowAdmin.UpdatedAt == nil {
			break
		}

		return e.complexity.ShowAdmin.UpdatedAt(childComplexity), true

	case "ShowAdmin.updatedBy":
		if e.complexity.ShowAdmin.UpdatedBy == nil {
			break
		}

		return e.complexity.ShowAdmin.UpdatedBy(childComplexity), true

	case "ShowAdmin.updatedByUserId":
		if e.complexity.ShowAdmin.UpdatedByUserID == nil {
			break
		}

		return e.complexity.ShowAdmin.UpdatedByUserID(childComplexity), true

	case "ShowAdmin.user":
		if e.complexity.ShowAdmin.User == nil {
			break
		}

		return e.complexity.ShowAdmin.User(childComplexity), true

	case "ShowAdmin.userId":
		if e.complexity.ShowAdmin.UserID == nil {
			break
		}

		return e.complexity.ShowAdmin.UserID(childComplexity), true

	case "ThirdPartyEpisode.absoluteNumber":
		if e.complexity.ThirdPartyEpisode.AbsoluteNumber == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.AbsoluteNumber(childComplexity), true

	case "ThirdPartyEpisode.id":
		if e.complexity.ThirdPartyEpisode.ID == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.ID(childComplexity), true

	case "ThirdPartyEpisode.name":
		if e.complexity.ThirdPartyEpisode.Name == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.Name(childComplexity), true

	case "ThirdPartyEpisode.number":
		if e.complexity.ThirdPartyEpisode.Number == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.Number(childComplexity), true

	case "ThirdPartyEpisode.season":
		if e.complexity.ThirdPartyEpisode.Season == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.Season(childComplexity), true

	case "ThirdPartyEpisode.source":
		if e.complexity.ThirdPartyEpisode.Source == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.Source(childComplexity), true

	case "ThirdPartyEpisode.timestamps":
		if e.complexity.ThirdPartyEpisode.Timestamps == nil {
			break
		}

		return e.complexity.ThirdPartyEpisode.Timestamps(childComplexity), true

	case "ThirdPartyTimestamp.at":
		if e.complexity.ThirdPartyTimestamp.At == nil {
			break
		}

		return e.complexity.ThirdPartyTimestamp.At(childComplexity), true

	case "ThirdPartyTimestamp.id":
		if e.complexity.ThirdPartyTimestamp.ID == nil {
			break
		}

		return e.complexity.ThirdPartyTimestamp.ID(childComplexity), true

	case "ThirdPartyTimestamp.type":
		if e.complexity.ThirdPartyTimestamp.Type == nil {
			break
		}

		return e.complexity.ThirdPartyTimestamp.Type(childComplexity), true

	case "ThirdPartyTimestamp.typeId":
		if e.complexity.ThirdPartyTimestamp.TypeID == nil {
			break
		}

		return e.complexity.ThirdPartyTimestamp.TypeID(childComplexity), true

	case "Timestamp.at":
		if e.complexity.Timestamp.At == nil {
			break
		}

		return e.complexity.Timestamp.At(childComplexity), true

	case "Timestamp.createdAt":
		if e.complexity.Timestamp.CreatedAt == nil {
			break
		}

		return e.complexity.Timestamp.CreatedAt(childComplexity), true

	case "Timestamp.createdBy":
		if e.complexity.Timestamp.CreatedBy == nil {
			break
		}

		return e.complexity.Timestamp.CreatedBy(childComplexity), true

	case "Timestamp.createdByUserId":
		if e.complexity.Timestamp.CreatedByUserID == nil {
			break
		}

		return e.complexity.Timestamp.CreatedByUserID(childComplexity), true

	case "Timestamp.deletedAt":
		if e.complexity.Timestamp.DeletedAt == nil {
			break
		}

		return e.complexity.Timestamp.DeletedAt(childComplexity), true

	case "Timestamp.deletedBy":
		if e.complexity.Timestamp.DeletedBy == nil {
			break
		}

		return e.complexity.Timestamp.DeletedBy(childComplexity), true

	case "Timestamp.deletedByUserId":
		if e.complexity.Timestamp.DeletedByUserID == nil {
			break
		}

		return e.complexity.Timestamp.DeletedByUserID(childComplexity), true

	case "Timestamp.episode":
		if e.complexity.Timestamp.Episode == nil {
			break
		}

		return e.complexity.Timestamp.Episode(childComplexity), true

	case "Timestamp.episodeId":
		if e.complexity.Timestamp.EpisodeID == nil {
			break
		}

		return e.complexity.Timestamp.EpisodeID(childComplexity), true

	case "Timestamp.id":
		if e.complexity.Timestamp.ID == nil {
			break
		}

		return e.complexity.Timestamp.ID(childComplexity), true

	case "Timestamp.source":
		if e.complexity.Timestamp.Source == nil {
			break
		}

		return e.complexity.Timestamp.Source(childComplexity), true

	case "Timestamp.type":
		if e.complexity.Timestamp.Type == nil {
			break
		}

		return e.complexity.Timestamp.Type(childComplexity), true

	case "Timestamp.typeId":
		if e.complexity.Timestamp.TypeID == nil {
			break
		}

		return e.complexity.Timestamp.TypeID(childComplexity), true

	case "Timestamp.updatedAt":
		if e.complexity.Timestamp.UpdatedAt == nil {
			break
		}

		return e.complexity.Timestamp.UpdatedAt(childComplexity), true

	case "Timestamp.updatedBy":
		if e.complexity.Timestamp.UpdatedBy == nil {
			break
		}

		return e.complexity.Timestamp.UpdatedBy(childComplexity), true

	case "Timestamp.updatedByUserId":
		if e.complexity.Timestamp.UpdatedByUserID == nil {
			break
		}

		return e.complexity.Timestamp.UpdatedByUserID(childComplexity), true

	case "TimestampType.createdAt":
		if e.complexity.TimestampType.CreatedAt == nil {
			break
		}

		return e.complexity.TimestampType.CreatedAt(childComplexity), true

	case "TimestampType.createdBy":
		if e.complexity.TimestampType.CreatedBy == nil {
			break
		}

		return e.complexity.TimestampType.CreatedBy(childComplexity), true

	case "TimestampType.createdByUserId":
		if e.complexity.TimestampType.CreatedByUserID == nil {
			break
		}

		return e.complexity.TimestampType.CreatedByUserID(childComplexity), true

	case "TimestampType.deletedAt":
		if e.complexity.TimestampType.DeletedAt == nil {
			break
		}

		return e.complexity.TimestampType.DeletedAt(childComplexity), true

	case "TimestampType.deletedBy":
		if e.complexity.TimestampType.DeletedBy == nil {
			break
		}

		return e.complexity.TimestampType.DeletedBy(childComplexity), true

	case "TimestampType.deletedByUserId":
		if e.complexity.TimestampType.DeletedByUserID == nil {
			break
		}

		return e.complexity.TimestampType.DeletedByUserID(childComplexity), true

	case "TimestampType.description":
		if e.complexity.TimestampType.Description == nil {
			break
		}

		return e.complexity.TimestampType.Description(childComplexity), true

	case "TimestampType.id":
		if e.complexity.TimestampType.ID == nil {
			break
		}

		return e.complexity.TimestampType.ID(childComplexity), true

	case "TimestampType.name":
		if e.complexity.TimestampType.Name == nil {
			break
		}

		return e.complexity.TimestampType.Name(childComplexity), true

	case "TimestampType.updatedAt":
		if e.complexity.TimestampType.UpdatedAt == nil {
			break
		}

		return e.complexity.TimestampType.UpdatedAt(childComplexity), true

	case "TimestampType.updatedBy":
		if e.complexity.TimestampType.UpdatedBy == nil {
			break
		}

		return e.complexity.TimestampType.UpdatedBy(childComplexity), true

	case "TimestampType.updatedByUserId":
		if e.complexity.TimestampType.UpdatedByUserID == nil {
			break
		}

		return e.complexity.TimestampType.UpdatedByUserID(childComplexity), true

	case "User.adminOfShows":
		if e.complexity.User.AdminOfShows == nil {
			break
		}

		return e.complexity.User.AdminOfShows(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.deletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.profileUrl":
		if e.complexity.User.ProfileURL == nil {
			break
		}

		return e.complexity.User.ProfileURL(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "internal/graphql/schemas/directives.graphql", Input: `"Check if the user is signed in"
directive @authorized on FIELD_DEFINITION

"Checks if the user is signed in and has a given role"
directive @hasRole(role: Role!) on FIELD_DEFINITION

"Checks if the user is signed in and is an admin of the show being operated on"
directive @isShowAdmin on ARGUMENT_DEFINITION
`, BuiltIn: false},
	{Name: "internal/graphql/schemas/enums.graphql", Input: `"""
A user's role in the system. Higher roles allow a user write access to certain data that a normal
user would not. Some queries and mutations are only alloed by certain roles
"""
enum Role {
  "Highest role. Has super user access to all queries and mutations"
  DEV
  "Administrator role. Has some elevated permissions"
  ADMIN
  "Basic role. Has no elevated permissions"
  USER
}

"""
Which of the supported services the ` + "`" + `EpisodeUrl` + "`" + ` was created for. This is a simple enum that allows
for simple checks, but this data can also be pulled from the url in the case of UNKNOWN
"""
enum EpisodeSource {
  "Data came from an external source"
  UNKNOWN
  "Data is from <vrv.co>"
  VRV
  "Data is from <funimation.com>"
  FUNIMATION
}

"Where a timestamp originated from"
enum TimestampSource {
  ANIME_SKIP
  BETTER_VRV
}
`, BuiltIn: false},
	{Name: "internal/graphql/schemas/models.graphql", Input: `"""
The base model has all the fields you would expect a fully fleshed out item in the database would
have. It is used to track who create, updated, and deleted items
"""
interface BaseModel {
  "Unique, v4 UUID. When asked for an ` + "`" + `id` + "`" + ` of an object, use this field"
  id: ID!
  "Time that the item was created at"
  createdAt: Time!
  "The user's ` + "`" + `id` + "`" + ` that created the item"
  createdByUserId: ID!
  "The entire user that created the item"
  createdBy: User!
  "Time that the item was updated at"
  updatedAt: Time!
  "The user's ` + "`" + `id` + "`" + ` that last updated the item"
  updatedByUserId: ID!
  "The entire user that last updated the item"
  updatedBy: User!
  "Time that the item was updated at. If this value is present, the item is considered deleted"
  deletedAt: Time
  "The user's ` + "`" + `id` + "`" + ` that deleted the item"
  deletedByUserId: ID
  "The entire user that deleted the item"
  deletedBy: User
}

"""
Basic information about an episode, including season, numbers, a list of timestamps, and urls that
it can be watched at
"""
type Episode implements BaseModel {
  id: ID!
  createdAt: Time!
  createdByUserId: ID!
  createdBy: User!
  updatedAt: Time!
  updatedByUserId: ID!
  updatedBy: User!
  deletedAt: Time
  deletedByUserId: ID
  deletedBy: User

  """
  The season number that this episode belongs to

  ### Examples:

  - "1"
  - "1 Directors Cut"
  - "2"
  - "Movies"
  """
  season: String
  """
  The episode number in the current season

  ### Examples:

  - "1"
  - "2"
  - "5.5"
  - "OVA 1"
  """
  number: String
  """
  The absolute episode number out of all the episodes of the show. Generally only regular episodes
  should have this field
  """
  absoluteNumber: String
  "The episode's name"
  name: String
  "The show that the episode belongs to"
  show: Show!
  "The id of the show that the episode blongs to"
  showId: ID!
  """
  The list of current timestamps. 

  Timestamps are apart apart of the ` + "`" + `Episode` + "`" + ` instead of the ` + "`" + `EpisodeUrl` + "`" + ` so that they can be shared
  between urls and not need duplicate data
  """
  timestamps: [Timestamp!]!
  "The list of urls and services that the episode can be accessed from"
  urls: [EpisodeUrl!]!
}

"""
Episode info provided by a third party. See ` + "`" + `Episode` + "`" + ` for a description of each field.

When creating data based on this type, fill out and post an episode, then timestamps based on the
data here. All fields will map 1 to 1 with the exception of ` + "`" + `source` + "`" + `. Since a source belongs to a
episode for third party data, but belongs to timestamps in Anime Skip, the source should be
propogated down to each of the timestamps. This way when more timestamps are added, a episode can
have muliple timestamp sources.

> Make sure to fill out the ` + "`" + `source` + "`" + ` field so that original owner of the timestamp is maintained
"""
type ThirdPartyEpisode {
  "The Anime Skip ` + "`" + `Episode.id` + "`" + ` when the ` + "`" + `source` + "`" + ` is ` + "`" + `ANIME_SKIP` + "`" + `, otherwise this is null"
  id: ID
  season: String
  number: String
  absoluteNumber: String
  name: String
  source: TimestampSource
  timestamps: [ThirdPartyTimestamp!]!
}

"Data required to create a new ` + "`" + `Episode` + "`" + `. See ` + "`" + `Episode` + "`" + ` for a description of each field"
input InputEpisode {
  "See ` + "`" + `Episode.season` + "`" + `"
  season: String
  "See ` + "`" + `Episode.number` + "`" + `"
  number: String
  "See ` + "`" + `Episode.absoluteNumber` + "`" + `"
  absoluteNumber: String
  "See ` + "`" + `Episode.name` + "`" + `"
  name: String
}

"Stores intormation about what where an episode can be watched from"
type EpisodeUrl {
  "The url that would take a user to watch the ` + "`" + `episode` + "`" + `"
  url: String!
  createdAt: Time!
  createdByUserId: ID!
  createdBy: User!
  updatedAt: Time!
  updatedByUserId: ID!
  updatedBy: User!

  "The ` + "`" + `Episode.id` + "`" + ` that this url belongs to"
  episodeId: ID!
  "The ` + "`" + `Episode` + "`" + ` that this url belongs to"
  episode: Episode!
  "What service this url points to"
  source: EpisodeSource!
}

"Data required to create a new ` + "`" + `EpisodeUrl` + "`" + `. See ` + "`" + `EpisodeUrl` + "`" + ` for a description of each field"
input InputEpisodeUrl {
  url: String!
}


"Account info that should only be accessible by the authorised user"
type Account {
  id: ID!
  createdAt: Time!
  deletedAt: Time

  "Unique string slug that is the easy to remember identifier"
  username: String!
  email: String!
  "Url to an image that is the user's profile picture"
  profileUrl: String!
  """
  The linking object that associates a user to the shows they are admins of.
  
  > This data is also accessible on the ` + "`" + `User` + "`" + ` model. It has been added here for convienience
  """
  adminOfShows: [ShowAdmin!]!

  "If the user's email is verified. Emails must be verified before the user can call a mutation"
  emailVerified: Boolean!
  "The user's administrative role. Most users are ` + "`" + `Role.USER` + "`" + `"
  role: Role!
  "The user's preferences"
  preferences: Preferences!
}

"""
Where all the user preferences are stored. This includes what timestamps the user doesn't want to
watch
"""
type Preferences {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time

  "The ` + "`" + `User.id` + "`" + ` that this preferences object belongs to"
  userId: ID!
  "The ` + "`" + `User` + "`" + ` that the preferences belong to"
  user: User!
  "Whether or not the user wants to automatically skip section. Default: ` + "`" + `true` + "`" + `"
  enableAutoSkip: Boolean!
  "Whether or not the user wants to auto-play the videos. Default: ` + "`" + `true` + "`" + `"
  enableAutoPlay: Boolean!
  "Whether or not the user whats to skip branding timestamps. Default: ` + "`" + `true` + "`" + `"
  skipBranding: Boolean!
  "Whether or not the user whats to skip regular intros. Default: ` + "`" + `true` + "`" + `"
  skipIntros: Boolean!
  "Whether or not the user whats to skip the first of an intro. Default: ` + "`" + `false` + "`" + `"
  skipNewIntros: Boolean!
  "Whether or not the user whats to kip intros that have plot progression rather than the standard animation. Default: ` + "`" + `false` + "`" + `"
  skipMixedIntros: Boolean!
  "Whether or not the user whats to skip recaps at the beginning of episodes. Default: ` + "`" + `true` + "`" + `"
  skipRecaps: Boolean!
  "Whether or not the user whats to skip filler content. Default: ` + "`" + `true` + "`" + `"
  skipFiller: Boolean!
  "Whether or not the user whats to skip canon content. Default: ` + "`" + `false` + "`" + `"
  skipCanon: Boolean!
  "Whether or not the user whats to skip commertial transitions. Default: ` + "`" + `true` + "`" + `"
  skipTransitions: Boolean!
  "Whether or not the user whats to skip credits/outros. Default: ` + "`" + `true` + "`" + `"
  skipCredits: Boolean!
  "Whether or not the user whats to skip the first of a credits/outro. Default: ` + "`" + `false` + "`" + `"
  skipNewCredits: Boolean!
  "Whether or not the user whats to skip credits/outros that have plot progression rather than the standard animation. Default: ` + "`" + `false` + "`" + `"
  skipMixedCredits: Boolean!
  "Whether or not to skip the next episode's preview. Default: ` + "`" + `true` + "`" + `"
  skipPreview: Boolean!
  "Whether or not to skip an episode's static title card. Default: ` + "`" + `true` + "`" + `"
  skipTitleCard: Boolean!
}

"Data required to update a user's ` + "`" + `Preferences` + "`" + `. See ` + "`" + `Preferences` + "`" + ` for a description of each field"
input InputPreferences {
  enableAutoSkip: Boolean!
  enableAutoPlay: Boolean!
  skipBranding: Boolean!
  skipIntros: Boolean!
  skipNewIntros: Boolean!
  skipMixedIntros: Boolean!
  skipRecaps: Boolean!
  skipFiller: Boolean!
  skipCanon: Boolean!
  skipTransitions: Boolean!
  skipCredits: Boolean!
  skipNewCredits: Boolean!
  skipMixedCredits: Boolean!
  skipPreview: Boolean!
  skipTitleCard: Boolean!
}


"A show containing a list of episodes and relevate links"
type Show implements BaseModel {
  id: ID!
  createdAt: Time!
  createdByUserId: ID!
  createdBy: User!
  updatedAt: Time!
  updatedByUserId: ID!
  updatedBy: User!
  deletedAt: Time
  deletedByUserId: ID
  deletedBy: User

  """
  The show name

  ### Examples

  - "Death Note"
  - "My Hero Academia"
  """
  name: String!
  """
  The show's original Japanese name

  ### Examples

  - "Desu Nto"
  - "Boku no Hr Akademia"
  """
  originalName: String
  "A link to the anime's official website"
  website: String
  "A link to a show poster"
  image: String
  "The list of admins for the show"
  admins: [ShowAdmin!]!
  "All the episodes that belong to the show"
  episodes: [Episode!]!
}

"Data required to create a new ` + "`" + `Show` + "`" + `. See ` + "`" + `Show` + "`" + ` for a description of each field"
input InputShow {
  name: String!
  originalName: String
  website: String
  image: String
}


"""
A list of users that have elevated permissions when making changes to a show, it's episodes, and
timestamps. Show admins are responsible for approving any changes that users might submit.

If a user has the ` + "`" + `ADMIN` + "`" + ` or ` + "`" + `DEV` + "`" + ` roles, they do not need to be show admins to approve changes or
make changes directly. Likewise, if a show doesn't have an admin, the user that create the
show/episode will have temporary access to editing the data until someone becomes that shows admin.

Admins can be created using the API and will soon come to the Anime Skip player/website.
"""
type ShowAdmin implements BaseModel {
  id: ID!
  createdAt: Time!
  createdByUserId: ID!
  createdBy: User!
  updatedAt: Time!
  updatedByUserId: ID!
  updatedBy: User!
  deletedAt: Time
  deletedByUserId: ID
  deletedBy: User

  "The ` + "`" + `Show.id` + "`" + ` that the admin has elevated privileges for"
  showId: ID!
  "The ` + "`" + `Show` + "`" + ` that the admin has elevated privileges for"
  show: Show!
  "The ` + "`" + `User.id` + "`" + ` that the admin privileges belong to"
  userId: ID!
  "The ` + "`" + `User` + "`" + ` that the admin privileges belong to"
  user: User!
}

"Data required to create a new ` + "`" + `ShowAdmin` + "`" + `. See ` + "`" + `ShowAdmin` + "`" + ` for a description of each field"
input InputShowAdmin {
  showId: ID!
  userId: ID!
}


type Timestamp implements BaseModel {
  id: ID!
  createdAt: Time!
  createdByUserId: ID!
  createdBy: User!
  updatedAt: Time!
  updatedByUserId: ID!
  updatedBy: User!
  deletedAt: Time
  deletedByUserId: ID
  deletedBy: User

  "The actual time the timestamp is at"
  at: Float!
  source: TimestampSource
  "The id specifying the type the timestamp is"
  typeId: ID!
  """
  The type the timestamp is. Thid field is a constant string so including it has no effect on
  performance or query complexity.
  """
  type: TimestampType!
  "The ` + "`" + `Episode.id` + "`" + ` that the timestamp belongs to"
  episodeId: ID!
  "The ` + "`" + `Episode` + "`" + ` that the timestamp belongs to"
  episode: Episode!
}

type ThirdPartyTimestamp {
  "The Anime Skip ` + "`" + `Timestamp.id` + "`" + ` when the ` + "`" + `Episode.source` + "`" + ` is ` + "`" + `ANIME_SKIP` + "`" + `, otherwise this is null"
  id: ID
  "The actual time the timestamp is at"
  at: Float!
  "The id specifying the type the timestamp is"
  typeId: ID!
  type: TimestampType!
}

"Data required to create a new ` + "`" + `Timestamp` + "`" + `. See ` + "`" + `Timestamp` + "`" + ` for a description of each field"
input InputTimestamp {
  at: Float!
  typeId: ID!
}


"""
The type a timestamp can be. This table rarely changes so the values fetched can either be hard
coded or fetch occasionaly. Anime Skip website and web extension use hardcoded maps to store this
data, but a third party might want to fetch and cache this instead since you won't know when Anime
Skip adds timestamps
"""
type TimestampType implements BaseModel {
  id: ID!
  createdAt: Time!
  createdByUserId: ID!
  createdBy: User!
  updatedAt: Time!
  updatedByUserId: ID!
  updatedBy: User!
  deletedAt: Time
  deletedByUserId: ID
  deletedBy: User

  "The name of the timestamp type"
  name: String!
  "The description for what this type represents"
  description: String!
}

"Data required to create a new ` + "`" + `TimestampType` + "`" + `. See ` + "`" + `TimestampType` + "`" + ` for a description of each field"
input InputTimestampType {
  name: String!
  description: String!
}


"Information about a user that is public. See ` + "`" + `Account` + "`" + ` for a description of each field"
type User {
  id: ID!
  createdAt: Time!
  deletedAt: Time

  username: String!
  profileUrl: String!
  adminOfShows: [ShowAdmin!]!
}
`, BuiltIn: false},
	{Name: "internal/graphql/schemas/mutations.graphql", Input: `type Mutation {
  # Account
  """
  Create a user account. 3rd party applciations will not have access to this function because of
  ` + "`" + `recaptchaResponse` + "`" + `. Redirect new users to create an account on <anime-skip.com>
  """
  createAccount(username: String!, email: String!, passwordHash: String!, recaptchaResponse: String!): LoginData
  "Resend the verification email for the account of the authenticated user"
  resendVerificationEmail: Boolean @authorized
  """
  Callback to handle the verfification token included in the email sent using
  ` + "`" + `resendVerificationEmail` + "`" + `
  """
  verifyEmailAddress(validationToken: String!): Account
  """
  Request your account be deleted. The user will recieve an email with a link to confirm deleting
  their account
  """
  deleteAccountRequest(passwordHash: String!): Account @authorized
  "Handle a deleteToken from ` + "`" + `deleteAccountRequest` + "`" + ` and actually delete the user's account"
  deleteAccount(deleteToken: String!): Account

  # Prefernces
  "Update user preferences"
  savePreferences(preferences: InputPreferences!): Preferences @authorized

  # Shows
  "Create a show and optionally become an admin"
  createShow(showInput: InputShow!, becomeAdmin: Boolean!): Show @authorized
  "Update show data"
  updateShow(showId: ID! @isShowAdmin, newShow: InputShow!): Show
  """
  Delete a show and all it's children (episodes, episode urls, timestamps, admins, etc)
  
  > ` + "`" + `@hasRole(role: ADMIN)` + "`" + ` - The user must have the ` + "`" + `ADMIN` + "`" + ` role to perform this action
  """
  deleteShow(showId: ID!): Show @hasRole(role: ADMIN)

  # Show Admins
  """
  Give admin privilege to a user for a show.
  
  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  createShowAdmin(showAdminInput: InputShowAdmin! @isShowAdmin): ShowAdmin
  """
  Remove admin privileges from a user for a show.
  
  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  deleteShowAdmin(showAdminId: ID! @isShowAdmin): ShowAdmin

  # Episodes
  """
  Create an episode under a ` + "`" + `Show` + "`" + `

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  createEpisode(showId: ID! @isShowAdmin, episodeInput: InputEpisode!): Episode
  """
  Update episode info

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  updateEpisode(episodeId: ID! @isShowAdmin, newEpisode: InputEpisode!): Episode
  """
  Delete an episode and all it's child data

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  deleteEpisode(episodeId: ID! @isShowAdmin): Episode

  # Episode Urls
  """
  Link an ` + "`" + `Episode` + "`" + ` to a service URL

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  createEpisodeUrl(episodeId: ID! @isShowAdmin, episodeUrlInput: InputEpisodeUrl!): EpisodeUrl
  """
  Unlink an ` + "`" + `Episode` + "`" + ` to from service URL

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  deleteEpisodeUrl(episodeUrl: String! @isShowAdmin): EpisodeUrl

  # Timestamps
  """
  Add a timestamp to an ` + "`" + `Episode` + "`" + `

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  createTimestamp(episodeId: ID! @isShowAdmin, timestampInput: InputTimestamp!): Timestamp
  """
  Update timestamp data

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  updateTimestamp(timestampId: ID! @isShowAdmin, newTimestamp: InputTimestamp!): Timestamp
  """
  Delete a timestamp

  > ` + "`" + `@isShowAdmin` + "`" + ` - You need to be an admin of the show to do this action
  """
  deleteTimestamp(timestampId: ID! @isShowAdmin): Timestamp

  # Timestamp Types
  """
  Create a timestamp type

  > ` + "`" + `@hasRole(role: ADMIN)` + "`" + ` - The user must have the ` + "`" + `ADMIN` + "`" + ` role to perform this action
  """
  createTimestampType(timestampTypeInput: InputTimestampType!): TimestampType @hasRole(role: ADMIN)
  """
  Update a timestamp type

  > ` + "`" + `@hasRole(role: ADMIN)` + "`" + ` - The user must have the ` + "`" + `ADMIN` + "`" + ` role to perform this action
  """
  updateTimestampType(timestampTypeId: ID!, newTimestampType: InputTimestampType!): TimestampType @hasRole(role: ADMIN)
  """
  Delete a timestamp type

  > ` + "`" + `@hasRole(role: ADMIN)` + "`" + ` - The user must have the ` + "`" + `ADMIN` + "`" + ` role to perform this action
  """
  deleteTimestampType(timestampTypeId: ID!): TimestampType  @hasRole(role: ADMIN)
}
`, BuiltIn: false},
	{Name: "internal/graphql/schemas/queries.graphql", Input: `type Query {
  # Account
  "Get the logged in user's private account information"
  account: Account @authorized
  """
  Use either the username or email and an md5 hash of the user's password to get an access and
  refresh token
  """
  login(usernameEmail: String!, passwordHash: String!): LoginData
  "Use a refresh token get a new access and refresh token"
  loginRefresh(refreshToken: String!): LoginData
  
  # Users
  "Find user with a matching ` + "`" + `User.id` + "`" + `"
  findUser(userId: ID!): User
  "Find user with a matching ` + "`" + `User.username` + "`" + `"
  findUserByUsername(username: String!): User

  # Shows
  "Find show with a matching ` + "`" + `Show.id` + "`" + `"
  findShow(showId: ID!): Show
  """
  Search for shows that include the ` + "`" + `search` + "`" + ` in the ` + "`" + `Show.name` + "`" + `. Results are sorted by ` + "`" + `Show.name` + "`" + `
  as ` + "`" + `ASC` + "`" + ` or ` + "`" + `DESC` + "`" + `
  """
  searchShows(search: String = "", offset: Int = 0, limit: Int = 25, sort: String = "ASC"): [Show!]

  # Show Admins
  "Find show admin with a matching ` + "`" + `ShowAdmin.id` + "`" + `"
  findShowAdmin(showAdminId: ID!): ShowAdmin
  "Get a list of admins for a given ` + "`" + `Show.id` + "`" + `"
  findShowAdminsByShowId(showId: ID!): [ShowAdmin!]
  "Get a list of show admins for a given ` + "`" + `User.id` + "`" + `"
  findShowAdminsByUserId(userId: ID!): [ShowAdmin!]

  # Episodes
  "Find episode with a matching ` + "`" + `Episode.id` + "`" + `"
  findEpisode(episodeId: ID!): Episode
  "Get a list of episodes for a given ` + "`" + `Show.id` + "`" + `"
  findEpisodesByShowId(showId: ID!): [Episode!]
  """
  Search for episodes that include the ` + "`" + `search` + "`" + ` in the ` + "`" + `Episode.name` + "`" + `. Results are sorted by
  ` + "`" + `Show.name` + "`" + `as ` + "`" + `ASC` + "`" + ` or ` + "`" + `DESC` + "`" + `

  Results can be limited to a single show by passing ` + "`" + `showId` + "`" + `
  """
  searchEpisodes(search: String = "", showId: ID, offset: Int = 0, limit: Int = 25, sort: String = "ASC"): [Episode!]
  """
  Get a list of third party episodes for a given ` + "`" + `Episode.name` + "`" + `. Since this can return an array of
  multiple items, always use ` + "`" + `findEpisodeUrl` + "`" + ` first, then fallback to this query.
  
  Current 3rd party timestamp providers include:
  - [BetterVRV](http://tuckerchap.in/BetterVRV/)

  > See ` + "`" + `ThirdPartyEpisode` + "`" + ` for more information about how to create data based on this type
  """
  findEpisodeByName(name: String!): [ThirdPartyEpisode]

  # Episode Urls
  """
  Find an episode based on a URL. This is the primary method used to lookup data for a known service
  URL. See ` + "`" + `findEpisodeByName` + "`" + ` for looking up fallback data.
  """
  findEpisodeUrl(episodeUrl: String!): EpisodeUrl
  "List all the ` + "`" + `EpisodeUrl` + "`" + `s for a given ` + "`" + `Episode.id` + "`" + `"
  findEpisodeUrlsByEpisodeId(episodeId: ID!): [EpisodeUrl!]

  # Timestamps
  "Get timestamp info based on a ` + "`" + `Timestamp.id` + "`" + `"
  findTimestamp(timestampId: ID!): Timestamp
  "Get all the timestamps for an episode"
  findTimestampsByEpisodeId(episodeId: ID!): [Timestamp!]

  # Timestamp Types
  "Get timestamp type info based on a ` + "`" + `TimestampType.id` + "`" + `"
  findTimestampType(timestampTypeId: ID!): TimestampType
  "List all the ` + "`" + `TimestampType` + "`" + `s. Items come back in a random order"
  allTimestampTypes: [TimestampType!]
}
`, BuiltIn: false},
	{Name: "internal/graphql/schemas/return_types.graphql", Input: `"""
When logging in with a password or refresh token, you can get new tokens and account info
"""
type LoginData {
  "A JWT that should be used in the header of all requests: ` + "`" + `Authorization: Bearer <authToken>` + "`" + `"
  authToken: String!
  "A JWT used for the ` + "`" + `loginRefresh` + "`" + ` query to get new ` + "`" + `LoginData` + "`" + `"
  refreshToken: String!
  "The personal account information of the user that got authenticated"
  account: Account!
}
`, BuiltIn: false},
	{Name: "internal/graphql/schemas/scalars.graphql", Input: `"""
Standard [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp in UTC

### Example 

` + "`" + `` + "`" + `` + "`" + `
2020-08-04T23:43:27Z
` + "`" + `` + "`" + `` + "`" + `
"""
scalar Time
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.Role
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("role"))
		arg0, err = ec.unmarshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("email"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["passwordHash"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("passwordHash"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["passwordHash"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["recaptchaResponse"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("recaptchaResponse"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["recaptchaResponse"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_createEpisodeUrl_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["episodeId"] = arg0
	var arg1 models.InputEpisodeURL
	if tmp, ok := rawArgs["episodeUrlInput"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeUrlInput"))
		arg1, err = ec.unmarshalNInputEpisodeUrl2animeskipcombackendinternalgraphqlmodelsInputEpisodeURL(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["episodeUrlInput"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["showId"] = arg0
	var arg1 models.InputEpisode
	if tmp, ok := rawArgs["episodeInput"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeInput"))
		arg1, err = ec.unmarshalNInputEpisode2animeskipcombackendinternalgraphqlmodelsInputEpisode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["episodeInput"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createShowAdmin_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.InputShowAdmin
	if tmp, ok := rawArgs["showAdminInput"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showAdminInput"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNInputShowAdmin2animeskipcombackendinternalgraphqlmodelsInputShowAdmin(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(models.InputShowAdmin); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be anime-skip.com/backend/internal/graphql/models.InputShowAdmin`, tmp)
		}
	}
	args["showAdminInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createShow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.InputShow
	if tmp, ok := rawArgs["showInput"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showInput"))
		arg0, err = ec.unmarshalNInputShow2animeskipcombackendinternalgraphqlmodelsInputShow(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showInput"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["becomeAdmin"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("becomeAdmin"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["becomeAdmin"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createTimestampType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.InputTimestampType
	if tmp, ok := rawArgs["timestampTypeInput"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampTypeInput"))
		arg0, err = ec.unmarshalNInputTimestampType2animeskipcombackendinternalgraphqlmodelsInputTimestampType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timestampTypeInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTimestamp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["episodeId"] = arg0
	var arg1 models.InputTimestamp
	if tmp, ok := rawArgs["timestampInput"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampInput"))
		arg1, err = ec.unmarshalNInputTimestamp2animeskipcombackendinternalgraphqlmodelsInputTimestamp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timestampInput"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAccountRequest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["passwordHash"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("passwordHash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["passwordHash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["deleteToken"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("deleteToken"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["deleteToken"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEpisodeUrl_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeUrl"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeUrl"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["episodeUrl"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["episodeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteShowAdmin_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showAdminId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showAdminId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["showAdminId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteShow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTimestampType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["timestampTypeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampTypeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timestampTypeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteTimestamp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["timestampId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["timestampId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_savePreferences_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.InputPreferences
	if tmp, ok := rawArgs["preferences"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("preferences"))
		arg0, err = ec.unmarshalNInputPreferences2animeskipcombackendinternalgraphqlmodelsInputPreferences(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["preferences"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["episodeId"] = arg0
	var arg1 models.InputEpisode
	if tmp, ok := rawArgs["newEpisode"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("newEpisode"))
		arg1, err = ec.unmarshalNInputEpisode2animeskipcombackendinternalgraphqlmodelsInputEpisode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newEpisode"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateShow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["showId"] = arg0
	var arg1 models.InputShow
	if tmp, ok := rawArgs["newShow"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("newShow"))
		arg1, err = ec.unmarshalNInputShow2animeskipcombackendinternalgraphqlmodelsInputShow(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newShow"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTimestampType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["timestampTypeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampTypeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timestampTypeId"] = arg0
	var arg1 models.InputTimestampType
	if tmp, ok := rawArgs["newTimestampType"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("newTimestampType"))
		arg1, err = ec.unmarshalNInputTimestampType2animeskipcombackendinternalgraphqlmodelsInputTimestampType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newTimestampType"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTimestamp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["timestampId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNID2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.IsShowAdmin == nil {
				return nil, errors.New("directive isShowAdmin is not implemented")
			}
			return ec.directives.IsShowAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, err
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
		}
	}
	args["timestampId"] = arg0
	var arg1 models.InputTimestamp
	if tmp, ok := rawArgs["newTimestamp"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("newTimestamp"))
		arg1, err = ec.unmarshalNInputTimestamp2animeskipcombackendinternalgraphqlmodelsInputTimestamp(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newTimestamp"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_verifyEmailAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["validationToken"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("validationToken"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["validationToken"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findEpisodeByName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findEpisodeUrl_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeUrl"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeUrl"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["episodeUrl"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findEpisodeUrlsByEpisodeId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["episodeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findEpisode_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["episodeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findEpisodesByShowId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findShowAdmin_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showAdminId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showAdminId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showAdminId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findShowAdminsByShowId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findShowAdminsByUserId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("userId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findShow_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findTimestampType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["timestampTypeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampTypeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timestampTypeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findTimestamp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["timestampId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("timestampId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["timestampId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findTimestampsByEpisodeId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["episodeId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("episodeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["episodeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findUserByUsername_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("userId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_loginRefresh_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["refreshToken"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("refreshToken"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["refreshToken"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["usernameEmail"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("usernameEmail"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["usernameEmail"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["passwordHash"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("passwordHash"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["passwordHash"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_searchEpisodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("search"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["showId"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
		arg1, err = ec.unmarshalOID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["showId"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("limit"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("sort"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_searchShows_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["search"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("search"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["search"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("offset"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("limit"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sort"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("sort"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sort"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Account_id(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_username(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_email(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_profileUrl(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_adminOfShows(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().AdminOfShows(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ShowAdmin)
	fc.Result = res
	return ec.marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_emailVerified(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailVerified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_role(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Role, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Role)
	fc.Result = res
	return ec.marshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_preferences(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().Preferences(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Preferences)
	fc.Result = res
	return ec.marshalNPreferences2animeskipcombackendinternalgraphqlmodelsPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_id(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_createdByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Episode().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_updatedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_updatedBy(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Episode().UpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_deletedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_deletedBy(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Episode().DeletedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_season(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Season, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_number(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_absoluteNumber(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsoluteNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_name(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_show(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Episode().Show(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Show)
	fc.Result = res
	return ec.marshalNShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_showId(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_timestamps(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Episode().Timestamps(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Timestamp)
	fc.Result = res
	return ec.marshalNTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Episode_urls(ctx context.Context, field graphql.CollectedField, obj *models.Episode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Episode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Episode().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.EpisodeURL)
	fc.Result = res
	return ec.marshalNEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_url(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_createdByUserId(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EpisodeUrl().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_updatedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_updatedBy(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EpisodeUrl().UpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_episodeId(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EpisodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_episode(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.EpisodeUrl().Episode(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Episode)
	fc.Result = res
	return ec.marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _EpisodeUrl_source(ctx context.Context, field graphql.CollectedField, obj *models.EpisodeURL) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "EpisodeUrl",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.EpisodeSource)
	fc.Result = res
	return ec.marshalNEpisodeSource2animeskipcombackendinternalgraphqlmodelsEpisodeSource(ctx, field.Selections, res)
}

func (ec *executionContext) _LoginData_authToken(ctx context.Context, field graphql.CollectedField, obj *models.LoginData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LoginData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LoginData_refreshToken(ctx context.Context, field graphql.CollectedField, obj *models.LoginData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LoginData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _LoginData_account(ctx context.Context, field graphql.CollectedField, obj *models.LoginData) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "LoginData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Account, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Account)
	fc.Result = res
	return ec.marshalNAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createAccount_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAccount(rctx, args["username"].(string), args["email"].(string), args["passwordHash"].(string), args["recaptchaResponse"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.LoginData)
	fc.Result = res
	return ec.marshalOLoginData2animeskipcombackendinternalgraphqlmodelsLoginData(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_resendVerificationEmail(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ResendVerificationEmail(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_verifyEmailAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_verifyEmailAddress_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().VerifyEmailAddress(rctx, args["validationToken"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Account)
	fc.Result = res
	return ec.marshalOAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteAccountRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteAccountRequest_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteAccountRequest(rctx, args["passwordHash"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Account); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.Account`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Account)
	fc.Result = res
	return ec.marshalOAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteAccount_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAccount(rctx, args["deleteToken"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Account)
	fc.Result = res
	return ec.marshalOAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_savePreferences(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_savePreferences_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SavePreferences(rctx, args["preferences"].(models.InputPreferences))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Preferences); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.Preferences`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Preferences)
	fc.Result = res
	return ec.marshalOPreferences2animeskipcombackendinternalgraphqlmodelsPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createShow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createShow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateShow(rctx, args["showInput"].(models.InputShow), args["becomeAdmin"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Show); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.Show`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Show)
	fc.Result = res
	return ec.marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateShow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateShow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateShow(rctx, args["showId"].(string), args["newShow"].(models.InputShow))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Show)
	fc.Result = res
	return ec.marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteShow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteShow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteShow(rctx, args["showId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Show); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.Show`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Show)
	fc.Result = res
	return ec.marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createShowAdmin(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createShowAdmin_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateShowAdmin(rctx, args["showAdminInput"].(models.InputShowAdmin))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ShowAdmin)
	fc.Result = res
	return ec.marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteShowAdmin(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteShowAdmin_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteShowAdmin(rctx, args["showAdminId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ShowAdmin)
	fc.Result = res
	return ec.marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createEpisode_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEpisode(rctx, args["showId"].(string), args["episodeInput"].(models.InputEpisode))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Episode)
	fc.Result = res
	return ec.marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateEpisode_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEpisode(rctx, args["episodeId"].(string), args["newEpisode"].(models.InputEpisode))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Episode)
	fc.Result = res
	return ec.marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteEpisode_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEpisode(rctx, args["episodeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Episode)
	fc.Result = res
	return ec.marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createEpisodeUrl(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createEpisodeUrl_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEpisodeURL(rctx, args["episodeId"].(string), args["episodeUrlInput"].(models.InputEpisodeURL))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.EpisodeURL)
	fc.Result = res
	return ec.marshalOEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteEpisodeUrl(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteEpisodeUrl_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEpisodeURL(rctx, args["episodeUrl"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.EpisodeURL)
	fc.Result = res
	return ec.marshalOEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createTimestamp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createTimestamp_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTimestamp(rctx, args["episodeId"].(string), args["timestampInput"].(models.InputTimestamp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateTimestamp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateTimestamp_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTimestamp(rctx, args["timestampId"].(string), args["newTimestamp"].(models.InputTimestamp))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteTimestamp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteTimestamp_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTimestamp(rctx, args["timestampId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createTimestampType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createTimestampType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTimestampType(rctx, args["timestampTypeInput"].(models.InputTimestampType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.TimestampType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.TimestampType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimestampType)
	fc.Result = res
	return ec.marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateTimestampType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateTimestampType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateTimestampType(rctx, args["timestampTypeId"].(string), args["newTimestampType"].(models.InputTimestampType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.TimestampType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.TimestampType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimestampType)
	fc.Result = res
	return ec.marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteTimestampType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteTimestampType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteTimestampType(rctx, args["timestampTypeId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.TimestampType); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.TimestampType`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimestampType)
	fc.Result = res
	return ec.marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_id(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_userId(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_user(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Preferences().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_enableAutoSkip(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableAutoSkip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_enableAutoPlay(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnableAutoPlay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipBranding(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipBranding, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipIntros(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipIntros, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipNewIntros(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipNewIntros, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipMixedIntros(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipMixedIntros, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipRecaps(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipRecaps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipFiller(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipFiller, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipCanon(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipCanon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipTransitions(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipTransitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipCredits(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipCredits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipNewCredits(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipNewCredits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipMixedCredits(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipMixedCredits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipPreview(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipPreview, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Preferences_skipTitleCard(ctx context.Context, field graphql.CollectedField, obj *models.Preferences) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Preferences",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SkipTitleCard, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_account(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Account(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Authorized == nil {
				return nil, errors.New("directive authorized is not implemented")
			}
			return ec.directives.Authorized(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, err
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Account); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *anime-skip.com/backend/internal/graphql/models.Account`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Account)
	fc.Result = res
	return ec.marshalOAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_login_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Login(rctx, args["usernameEmail"].(string), args["passwordHash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.LoginData)
	fc.Result = res
	return ec.marshalOLoginData2animeskipcombackendinternalgraphqlmodelsLoginData(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_loginRefresh(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_loginRefresh_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LoginRefresh(rctx, args["refreshToken"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.LoginData)
	fc.Result = res
	return ec.marshalOLoginData2animeskipcombackendinternalgraphqlmodelsLoginData(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindUser(rctx, args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findUserByUsername(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findUserByUsername_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindUserByUsername(rctx, args["username"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findShow(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findShow_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindShow(rctx, args["showId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Show)
	fc.Result = res
	return ec.marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_searchShows(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_searchShows_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchShows(rctx, args["search"].(*string), args["offset"].(*int), args["limit"].(*int), args["sort"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Show)
	fc.Result = res
	return ec.marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findShowAdmin(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findShowAdmin_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindShowAdmin(rctx, args["showAdminId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ShowAdmin)
	fc.Result = res
	return ec.marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findShowAdminsByShowId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findShowAdminsByShowId_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindShowAdminsByShowID(rctx, args["showId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ShowAdmin)
	fc.Result = res
	return ec.marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findShowAdminsByUserId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findShowAdminsByUserId_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindShowAdminsByUserID(rctx, args["userId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ShowAdmin)
	fc.Result = res
	return ec.marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findEpisode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findEpisode_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindEpisode(rctx, args["episodeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Episode)
	fc.Result = res
	return ec.marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findEpisodesByShowId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findEpisodesByShowId_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindEpisodesByShowID(rctx, args["showId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Episode)
	fc.Result = res
	return ec.marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_searchEpisodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_searchEpisodes_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchEpisodes(rctx, args["search"].(*string), args["showId"].(*string), args["offset"].(*int), args["limit"].(*int), args["sort"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Episode)
	fc.Result = res
	return ec.marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findEpisodeByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findEpisodeByName_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindEpisodeByName(rctx, args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ThirdPartyEpisode)
	fc.Result = res
	return ec.marshalOThirdPartyEpisode2animeskipcombackendinternalgraphqlmodelsThirdPartyEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findEpisodeUrl(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findEpisodeUrl_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindEpisodeURL(rctx, args["episodeUrl"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.EpisodeURL)
	fc.Result = res
	return ec.marshalOEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findEpisodeUrlsByEpisodeId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findEpisodeUrlsByEpisodeId_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindEpisodeUrlsByEpisodeID(rctx, args["episodeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.EpisodeURL)
	fc.Result = res
	return ec.marshalOEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findTimestamp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findTimestamp_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindTimestamp(rctx, args["timestampId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findTimestampsByEpisodeId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findTimestampsByEpisodeId_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindTimestampsByEpisodeID(rctx, args["episodeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Timestamp)
	fc.Result = res
	return ec.marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_findTimestampType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_findTimestampType_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FindTimestampType(rctx, args["timestampTypeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimestampType)
	fc.Result = res
	return ec.marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allTimestampTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllTimestampTypes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.TimestampType)
	fc.Result = res
	return ec.marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_id(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_createdByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Show().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_updatedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_updatedBy(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Show().UpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_deletedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_deletedBy(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Show().DeletedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_name(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_originalName(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginalName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_website(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Website, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_image(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_admins(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Show().Admins(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ShowAdmin)
	fc.Result = res
	return ec.marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) _Show_episodes(ctx context.Context, field graphql.CollectedField, obj *models.Show) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Show",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Show().Episodes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Episode)
	fc.Result = res
	return ec.marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_id(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_createdByUserId(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ShowAdmin().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_updatedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_updatedBy(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ShowAdmin().UpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_deletedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_deletedBy(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ShowAdmin().DeletedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_showId(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShowID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_show(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ShowAdmin().Show(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Show)
	fc.Result = res
	return ec.marshalNShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_userId(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ShowAdmin_user(ctx context.Context, field graphql.CollectedField, obj *models.ShowAdmin) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ShowAdmin",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ShowAdmin().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_id(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_season(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Season, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_number(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_absoluteNumber(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsoluteNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_name(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_source(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimestampSource)
	fc.Result = res
	return ec.marshalOTimestampSource2animeskipcombackendinternalgraphqlmodelsTimestampSource(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyEpisode_timestamps(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyEpisode) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyEpisode",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ThirdPartyEpisode().Timestamps(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ThirdPartyTimestamp)
	fc.Result = res
	return ec.marshalNThirdPartyTimestamp2animeskipcombackendinternalgraphqlmodelsThirdPartyTimestamp(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyTimestamp_id(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyTimestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyTimestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyTimestamp_at(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyTimestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyTimestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.At, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyTimestamp_typeId(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyTimestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyTimestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ThirdPartyTimestamp_type(ctx context.Context, field graphql.CollectedField, obj *models.ThirdPartyTimestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "ThirdPartyTimestamp",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ThirdPartyTimestamp().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.TimestampType)
	fc.Result = res
	return ec.marshalNTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_id(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_createdByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Timestamp().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_updatedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_updatedBy(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Timestamp().UpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_deletedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_deletedBy(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Timestamp().DeletedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_at(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.At, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_source(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimestampSource)
	fc.Result = res
	return ec.marshalOTimestampSource2animeskipcombackendinternalgraphqlmodelsTimestampSource(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_typeId(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_type(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Timestamp().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.TimestampType)
	fc.Result = res
	return ec.marshalNTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_episodeId(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EpisodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timestamp_episode(ctx context.Context, field graphql.CollectedField, obj *models.Timestamp) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "Timestamp",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Timestamp().Episode(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Episode)
	fc.Result = res
	return ec.marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_id(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_createdByUserId(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_createdBy(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TimestampType().CreatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_updatedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_updatedBy(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TimestampType().UpdatedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_deletedByUserId(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedByUserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_deletedBy(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TimestampType().DeletedBy(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_name(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TimestampType_description(ctx context.Context, field graphql.CollectedField, obj *models.TimestampType) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "TimestampType",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _User_deletedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_profileUrl(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_adminOfShows(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().AdminOfShows(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.ShowAdmin)
	fc.Result = res
	return ec.marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputInputEpisode(ctx context.Context, obj interface{}) (models.InputEpisode, error) {
	var it models.InputEpisode
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "season":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("season"))
			it.Season, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "number":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("number"))
			it.Number, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "absoluteNumber":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("absoluteNumber"))
			it.AbsoluteNumber, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInputEpisodeUrl(ctx context.Context, obj interface{}) (models.InputEpisodeURL, error) {
	var it models.InputEpisodeURL
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "url":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("url"))
			it.URL, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInputPreferences(ctx context.Context, obj interface{}) (models.InputPreferences, error) {
	var it models.InputPreferences
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "enableAutoSkip":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("enableAutoSkip"))
			it.EnableAutoSkip, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "enableAutoPlay":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("enableAutoPlay"))
			it.EnableAutoPlay, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipBranding":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipBranding"))
			it.SkipBranding, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipIntros":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipIntros"))
			it.SkipIntros, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipNewIntros":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipNewIntros"))
			it.SkipNewIntros, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipMixedIntros":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipMixedIntros"))
			it.SkipMixedIntros, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipRecaps":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipRecaps"))
			it.SkipRecaps, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipFiller":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipFiller"))
			it.SkipFiller, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipCanon":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipCanon"))
			it.SkipCanon, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipTransitions":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipTransitions"))
			it.SkipTransitions, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipCredits":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipCredits"))
			it.SkipCredits, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipNewCredits":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipNewCredits"))
			it.SkipNewCredits, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipMixedCredits":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipMixedCredits"))
			it.SkipMixedCredits, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipPreview":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipPreview"))
			it.SkipPreview, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "skipTitleCard":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("skipTitleCard"))
			it.SkipTitleCard, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInputShow(ctx context.Context, obj interface{}) (models.InputShow, error) {
	var it models.InputShow
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "originalName":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("originalName"))
			it.OriginalName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "website":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("website"))
			it.Website, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "image":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("image"))
			it.Image, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInputShowAdmin(ctx context.Context, obj interface{}) (models.InputShowAdmin, error) {
	var it models.InputShowAdmin
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "showId":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("showId"))
			it.ShowID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("userId"))
			it.UserID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInputTimestamp(ctx context.Context, obj interface{}) (models.InputTimestamp, error) {
	var it models.InputTimestamp
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "at":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("at"))
			it.At, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "typeId":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("typeId"))
			it.TypeID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInputTimestampType(ctx context.Context, obj interface{}) (models.InputTimestampType, error) {
	var it models.InputTimestampType
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithField("description"))
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _BaseModel(ctx context.Context, sel ast.SelectionSet, obj models.BaseModel) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.Episode:
		return ec._Episode(ctx, sel, &obj)
	case *models.Episode:
		if obj == nil {
			return graphql.Null
		}
		return ec._Episode(ctx, sel, obj)
	case models.Show:
		return ec._Show(ctx, sel, &obj)
	case *models.Show:
		if obj == nil {
			return graphql.Null
		}
		return ec._Show(ctx, sel, obj)
	case models.ShowAdmin:
		return ec._ShowAdmin(ctx, sel, &obj)
	case *models.ShowAdmin:
		if obj == nil {
			return graphql.Null
		}
		return ec._ShowAdmin(ctx, sel, obj)
	case models.Timestamp:
		return ec._Timestamp(ctx, sel, &obj)
	case *models.Timestamp:
		if obj == nil {
			return graphql.Null
		}
		return ec._Timestamp(ctx, sel, obj)
	case models.TimestampType:
		return ec._TimestampType(ctx, sel, &obj)
	case *models.TimestampType:
		if obj == nil {
			return graphql.Null
		}
		return ec._TimestampType(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accountImplementors = []string{"Account"}

func (ec *executionContext) _Account(ctx context.Context, sel ast.SelectionSet, obj *models.Account) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Account")
		case "id":
			out.Values[i] = ec._Account_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Account_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Account_deletedAt(ctx, field, obj)
		case "username":
			out.Values[i] = ec._Account_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":
			out.Values[i] = ec._Account_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "profileUrl":
			out.Values[i] = ec._Account_profileUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adminOfShows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_adminOfShows(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "emailVerified":
			out.Values[i] = ec._Account_emailVerified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "role":
			out.Values[i] = ec._Account_role(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "preferences":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_preferences(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var episodeImplementors = []string{"Episode", "BaseModel"}

func (ec *executionContext) _Episode(ctx context.Context, sel ast.SelectionSet, obj *models.Episode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, episodeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Episode")
		case "id":
			out.Values[i] = ec._Episode_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Episode_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdByUserId":
			out.Values[i] = ec._Episode_createdByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Episode_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._Episode_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedByUserId":
			out.Values[i] = ec._Episode_updatedByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Episode_updatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deletedAt":
			out.Values[i] = ec._Episode_deletedAt(ctx, field, obj)
		case "deletedByUserId":
			out.Values[i] = ec._Episode_deletedByUserId(ctx, field, obj)
		case "deletedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Episode_deletedBy(ctx, field, obj)
				return res
			})
		case "season":
			out.Values[i] = ec._Episode_season(ctx, field, obj)
		case "number":
			out.Values[i] = ec._Episode_number(ctx, field, obj)
		case "absoluteNumber":
			out.Values[i] = ec._Episode_absoluteNumber(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Episode_name(ctx, field, obj)
		case "show":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Episode_show(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "showId":
			out.Values[i] = ec._Episode_showId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timestamps":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Episode_timestamps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "urls":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Episode_urls(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var episodeUrlImplementors = []string{"EpisodeUrl"}

func (ec *executionContext) _EpisodeUrl(ctx context.Context, sel ast.SelectionSet, obj *models.EpisodeURL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, episodeUrlImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EpisodeUrl")
		case "url":
			out.Values[i] = ec._EpisodeUrl_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._EpisodeUrl_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdByUserId":
			out.Values[i] = ec._EpisodeUrl_createdByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EpisodeUrl_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._EpisodeUrl_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedByUserId":
			out.Values[i] = ec._EpisodeUrl_updatedByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EpisodeUrl_updatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "episodeId":
			out.Values[i] = ec._EpisodeUrl_episodeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "episode":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._EpisodeUrl_episode(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "source":
			out.Values[i] = ec._EpisodeUrl_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loginDataImplementors = []string{"LoginData"}

func (ec *executionContext) _LoginData(ctx context.Context, sel ast.SelectionSet, obj *models.LoginData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginDataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginData")
		case "authToken":
			out.Values[i] = ec._LoginData_authToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "refreshToken":
			out.Values[i] = ec._LoginData_refreshToken(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "account":
			out.Values[i] = ec._LoginData_account(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createAccount":
			out.Values[i] = ec._Mutation_createAccount(ctx, field)
		case "resendVerificationEmail":
			out.Values[i] = ec._Mutation_resendVerificationEmail(ctx, field)
		case "verifyEmailAddress":
			out.Values[i] = ec._Mutation_verifyEmailAddress(ctx, field)
		case "deleteAccountRequest":
			out.Values[i] = ec._Mutation_deleteAccountRequest(ctx, field)
		case "deleteAccount":
			out.Values[i] = ec._Mutation_deleteAccount(ctx, field)
		case "savePreferences":
			out.Values[i] = ec._Mutation_savePreferences(ctx, field)
		case "createShow":
			out.Values[i] = ec._Mutation_createShow(ctx, field)
		case "updateShow":
			out.Values[i] = ec._Mutation_updateShow(ctx, field)
		case "deleteShow":
			out.Values[i] = ec._Mutation_deleteShow(ctx, field)
		case "createShowAdmin":
			out.Values[i] = ec._Mutation_createShowAdmin(ctx, field)
		case "deleteShowAdmin":
			out.Values[i] = ec._Mutation_deleteShowAdmin(ctx, field)
		case "createEpisode":
			out.Values[i] = ec._Mutation_createEpisode(ctx, field)
		case "updateEpisode":
			out.Values[i] = ec._Mutation_updateEpisode(ctx, field)
		case "deleteEpisode":
			out.Values[i] = ec._Mutation_deleteEpisode(ctx, field)
		case "createEpisodeUrl":
			out.Values[i] = ec._Mutation_createEpisodeUrl(ctx, field)
		case "deleteEpisodeUrl":
			out.Values[i] = ec._Mutation_deleteEpisodeUrl(ctx, field)
		case "createTimestamp":
			out.Values[i] = ec._Mutation_createTimestamp(ctx, field)
		case "updateTimestamp":
			out.Values[i] = ec._Mutation_updateTimestamp(ctx, field)
		case "deleteTimestamp":
			out.Values[i] = ec._Mutation_deleteTimestamp(ctx, field)
		case "createTimestampType":
			out.Values[i] = ec._Mutation_createTimestampType(ctx, field)
		case "updateTimestampType":
			out.Values[i] = ec._Mutation_updateTimestampType(ctx, field)
		case "deleteTimestampType":
			out.Values[i] = ec._Mutation_deleteTimestampType(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var preferencesImplementors = []string{"Preferences"}

func (ec *executionContext) _Preferences(ctx context.Context, sel ast.SelectionSet, obj *models.Preferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preferencesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Preferences")
		case "id":
			out.Values[i] = ec._Preferences_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Preferences_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Preferences_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._Preferences_deletedAt(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._Preferences_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Preferences_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "enableAutoSkip":
			out.Values[i] = ec._Preferences_enableAutoSkip(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "enableAutoPlay":
			out.Values[i] = ec._Preferences_enableAutoPlay(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipBranding":
			out.Values[i] = ec._Preferences_skipBranding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipIntros":
			out.Values[i] = ec._Preferences_skipIntros(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipNewIntros":
			out.Values[i] = ec._Preferences_skipNewIntros(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipMixedIntros":
			out.Values[i] = ec._Preferences_skipMixedIntros(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipRecaps":
			out.Values[i] = ec._Preferences_skipRecaps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipFiller":
			out.Values[i] = ec._Preferences_skipFiller(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipCanon":
			out.Values[i] = ec._Preferences_skipCanon(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipTransitions":
			out.Values[i] = ec._Preferences_skipTransitions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipCredits":
			out.Values[i] = ec._Preferences_skipCredits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipNewCredits":
			out.Values[i] = ec._Preferences_skipNewCredits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipMixedCredits":
			out.Values[i] = ec._Preferences_skipMixedCredits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipPreview":
			out.Values[i] = ec._Preferences_skipPreview(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skipTitleCard":
			out.Values[i] = ec._Preferences_skipTitleCard(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "account":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_account(ctx, field)
				return res
			})
		case "login":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_login(ctx, field)
				return res
			})
		case "loginRefresh":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_loginRefresh(ctx, field)
				return res
			})
		case "findUser":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findUser(ctx, field)
				return res
			})
		case "findUserByUsername":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findUserByUsername(ctx, field)
				return res
			})
		case "findShow":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findShow(ctx, field)
				return res
			})
		case "searchShows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchShows(ctx, field)
				return res
			})
		case "findShowAdmin":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findShowAdmin(ctx, field)
				return res
			})
		case "findShowAdminsByShowId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findShowAdminsByShowId(ctx, field)
				return res
			})
		case "findShowAdminsByUserId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findShowAdminsByUserId(ctx, field)
				return res
			})
		case "findEpisode":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findEpisode(ctx, field)
				return res
			})
		case "findEpisodesByShowId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findEpisodesByShowId(ctx, field)
				return res
			})
		case "searchEpisodes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchEpisodes(ctx, field)
				return res
			})
		case "findEpisodeByName":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findEpisodeByName(ctx, field)
				return res
			})
		case "findEpisodeUrl":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findEpisodeUrl(ctx, field)
				return res
			})
		case "findEpisodeUrlsByEpisodeId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findEpisodeUrlsByEpisodeId(ctx, field)
				return res
			})
		case "findTimestamp":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTimestamp(ctx, field)
				return res
			})
		case "findTimestampsByEpisodeId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTimestampsByEpisodeId(ctx, field)
				return res
			})
		case "findTimestampType":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTimestampType(ctx, field)
				return res
			})
		case "allTimestampTypes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allTimestampTypes(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var showImplementors = []string{"Show", "BaseModel"}

func (ec *executionContext) _Show(ctx context.Context, sel ast.SelectionSet, obj *models.Show) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, showImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Show")
		case "id":
			out.Values[i] = ec._Show_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Show_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdByUserId":
			out.Values[i] = ec._Show_createdByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Show_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._Show_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedByUserId":
			out.Values[i] = ec._Show_updatedByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Show_updatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deletedAt":
			out.Values[i] = ec._Show_deletedAt(ctx, field, obj)
		case "deletedByUserId":
			out.Values[i] = ec._Show_deletedByUserId(ctx, field, obj)
		case "deletedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Show_deletedBy(ctx, field, obj)
				return res
			})
		case "name":
			out.Values[i] = ec._Show_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "originalName":
			out.Values[i] = ec._Show_originalName(ctx, field, obj)
		case "website":
			out.Values[i] = ec._Show_website(ctx, field, obj)
		case "image":
			out.Values[i] = ec._Show_image(ctx, field, obj)
		case "admins":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Show_admins(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "episodes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Show_episodes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var showAdminImplementors = []string{"ShowAdmin", "BaseModel"}

func (ec *executionContext) _ShowAdmin(ctx context.Context, sel ast.SelectionSet, obj *models.ShowAdmin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, showAdminImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ShowAdmin")
		case "id":
			out.Values[i] = ec._ShowAdmin_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._ShowAdmin_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdByUserId":
			out.Values[i] = ec._ShowAdmin_createdByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ShowAdmin_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._ShowAdmin_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedByUserId":
			out.Values[i] = ec._ShowAdmin_updatedByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ShowAdmin_updatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deletedAt":
			out.Values[i] = ec._ShowAdmin_deletedAt(ctx, field, obj)
		case "deletedByUserId":
			out.Values[i] = ec._ShowAdmin_deletedByUserId(ctx, field, obj)
		case "deletedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ShowAdmin_deletedBy(ctx, field, obj)
				return res
			})
		case "showId":
			out.Values[i] = ec._ShowAdmin_showId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "show":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ShowAdmin_show(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "userId":
			out.Values[i] = ec._ShowAdmin_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ShowAdmin_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var thirdPartyEpisodeImplementors = []string{"ThirdPartyEpisode"}

func (ec *executionContext) _ThirdPartyEpisode(ctx context.Context, sel ast.SelectionSet, obj *models.ThirdPartyEpisode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, thirdPartyEpisodeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ThirdPartyEpisode")
		case "id":
			out.Values[i] = ec._ThirdPartyEpisode_id(ctx, field, obj)
		case "season":
			out.Values[i] = ec._ThirdPartyEpisode_season(ctx, field, obj)
		case "number":
			out.Values[i] = ec._ThirdPartyEpisode_number(ctx, field, obj)
		case "absoluteNumber":
			out.Values[i] = ec._ThirdPartyEpisode_absoluteNumber(ctx, field, obj)
		case "name":
			out.Values[i] = ec._ThirdPartyEpisode_name(ctx, field, obj)
		case "source":
			out.Values[i] = ec._ThirdPartyEpisode_source(ctx, field, obj)
		case "timestamps":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ThirdPartyEpisode_timestamps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var thirdPartyTimestampImplementors = []string{"ThirdPartyTimestamp"}

func (ec *executionContext) _ThirdPartyTimestamp(ctx context.Context, sel ast.SelectionSet, obj *models.ThirdPartyTimestamp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, thirdPartyTimestampImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ThirdPartyTimestamp")
		case "id":
			out.Values[i] = ec._ThirdPartyTimestamp_id(ctx, field, obj)
		case "at":
			out.Values[i] = ec._ThirdPartyTimestamp_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "typeId":
			out.Values[i] = ec._ThirdPartyTimestamp_typeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ThirdPartyTimestamp_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var timestampImplementors = []string{"Timestamp", "BaseModel"}

func (ec *executionContext) _Timestamp(ctx context.Context, sel ast.SelectionSet, obj *models.Timestamp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, timestampImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Timestamp")
		case "id":
			out.Values[i] = ec._Timestamp_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._Timestamp_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdByUserId":
			out.Values[i] = ec._Timestamp_createdByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Timestamp_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._Timestamp_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedByUserId":
			out.Values[i] = ec._Timestamp_updatedByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Timestamp_updatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deletedAt":
			out.Values[i] = ec._Timestamp_deletedAt(ctx, field, obj)
		case "deletedByUserId":
			out.Values[i] = ec._Timestamp_deletedByUserId(ctx, field, obj)
		case "deletedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Timestamp_deletedBy(ctx, field, obj)
				return res
			})
		case "at":
			out.Values[i] = ec._Timestamp_at(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":
			out.Values[i] = ec._Timestamp_source(ctx, field, obj)
		case "typeId":
			out.Values[i] = ec._Timestamp_typeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Timestamp_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "episodeId":
			out.Values[i] = ec._Timestamp_episodeId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "episode":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Timestamp_episode(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var timestampTypeImplementors = []string{"TimestampType", "BaseModel"}

func (ec *executionContext) _TimestampType(ctx context.Context, sel ast.SelectionSet, obj *models.TimestampType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, timestampTypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TimestampType")
		case "id":
			out.Values[i] = ec._TimestampType_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._TimestampType_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdByUserId":
			out.Values[i] = ec._TimestampType_createdByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TimestampType_createdBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "updatedAt":
			out.Values[i] = ec._TimestampType_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedByUserId":
			out.Values[i] = ec._TimestampType_updatedByUserId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updatedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TimestampType_updatedBy(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "deletedAt":
			out.Values[i] = ec._TimestampType_deletedAt(ctx, field, obj)
		case "deletedByUserId":
			out.Values[i] = ec._TimestampType_deletedByUserId(ctx, field, obj)
		case "deletedBy":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TimestampType_deletedBy(ctx, field, obj)
				return res
			})
		case "name":
			out.Values[i] = ec._TimestampType_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._TimestampType_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			out.Values[i] = ec._User_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "deletedAt":
			out.Values[i] = ec._User_deletedAt(ctx, field, obj)
		case "username":
			out.Values[i] = ec._User_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "profileUrl":
			out.Values[i] = ec._User_profileUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adminOfShows":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_adminOfShows(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx context.Context, sel ast.SelectionSet, v *models.Account) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx context.Context, sel ast.SelectionSet, v models.Episode) graphql.Marshaler {
	return ec._Episode(ctx, sel, &v)
}

func (ec *executionContext) marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx context.Context, sel ast.SelectionSet, v []*models.Episode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx context.Context, sel ast.SelectionSet, v *models.Episode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Episode(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEpisodeSource2animeskipcombackendinternalgraphqlmodelsEpisodeSource(ctx context.Context, v interface{}) (models.EpisodeSource, error) {
	var res models.EpisodeSource
	err := res.UnmarshalGQL(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNEpisodeSource2animeskipcombackendinternalgraphqlmodelsEpisodeSource(ctx context.Context, sel ast.SelectionSet, v models.EpisodeSource) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx context.Context, sel ast.SelectionSet, v []*models.EpisodeURL) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx context.Context, sel ast.SelectionSet, v *models.EpisodeURL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._EpisodeUrl(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInputEpisode2animeskipcombackendinternalgraphqlmodelsInputEpisode(ctx context.Context, v interface{}) (models.InputEpisode, error) {
	res, err := ec.unmarshalInputInputEpisode(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) unmarshalNInputEpisodeUrl2animeskipcombackendinternalgraphqlmodelsInputEpisodeURL(ctx context.Context, v interface{}) (models.InputEpisodeURL, error) {
	res, err := ec.unmarshalInputInputEpisodeUrl(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) unmarshalNInputPreferences2animeskipcombackendinternalgraphqlmodelsInputPreferences(ctx context.Context, v interface{}) (models.InputPreferences, error) {
	res, err := ec.unmarshalInputInputPreferences(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) unmarshalNInputShow2animeskipcombackendinternalgraphqlmodelsInputShow(ctx context.Context, v interface{}) (models.InputShow, error) {
	res, err := ec.unmarshalInputInputShow(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) unmarshalNInputShowAdmin2animeskipcombackendinternalgraphqlmodelsInputShowAdmin(ctx context.Context, v interface{}) (models.InputShowAdmin, error) {
	res, err := ec.unmarshalInputInputShowAdmin(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) unmarshalNInputTimestamp2animeskipcombackendinternalgraphqlmodelsInputTimestamp(ctx context.Context, v interface{}) (models.InputTimestamp, error) {
	res, err := ec.unmarshalInputInputTimestamp(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) unmarshalNInputTimestampType2animeskipcombackendinternalgraphqlmodelsInputTimestampType(ctx context.Context, v interface{}) (models.InputTimestampType, error) {
	res, err := ec.unmarshalInputInputTimestampType(ctx, v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNPreferences2animeskipcombackendinternalgraphqlmodelsPreferences(ctx context.Context, sel ast.SelectionSet, v models.Preferences) graphql.Marshaler {
	return ec._Preferences(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreferences2animeskipcombackendinternalgraphqlmodelsPreferences(ctx context.Context, sel ast.SelectionSet, v *models.Preferences) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Preferences(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx context.Context, v interface{}) (models.Role, error) {
	var res models.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNRole2animeskipcombackendinternalgraphqlmodelsRole(ctx context.Context, sel ast.SelectionSet, v models.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNShow2animeskipcombackendinternalgraphqlmodelsShow(ctx context.Context, sel ast.SelectionSet, v models.Show) graphql.Marshaler {
	return ec._Show(ctx, sel, &v)
}

func (ec *executionContext) marshalNShow2animeskipcombackendinternalgraphqlmodelsShow(ctx context.Context, sel ast.SelectionSet, v *models.Show) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Show(ctx, sel, v)
}

func (ec *executionContext) marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx context.Context, sel ast.SelectionSet, v []*models.ShowAdmin) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx context.Context, sel ast.SelectionSet, v *models.ShowAdmin) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ShowAdmin(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNThirdPartyTimestamp2animeskipcombackendinternalgraphqlmodelsThirdPartyTimestamp(ctx context.Context, sel ast.SelectionSet, v []*models.ThirdPartyTimestamp) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNThirdPartyTimestamp2animeskipcombackendinternalgraphqlmodelsThirdPartyTimestamp(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNThirdPartyTimestamp2animeskipcombackendinternalgraphqlmodelsThirdPartyTimestamp(ctx context.Context, sel ast.SelectionSet, v *models.ThirdPartyTimestamp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ThirdPartyTimestamp(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx context.Context, sel ast.SelectionSet, v []*models.Timestamp) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx context.Context, sel ast.SelectionSet, v *models.Timestamp) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Timestamp(ctx, sel, v)
}

func (ec *executionContext) marshalNTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx context.Context, sel ast.SelectionSet, v models.TimestampType) graphql.Marshaler {
	return ec._TimestampType(ctx, sel, &v)
}

func (ec *executionContext) marshalNTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx context.Context, sel ast.SelectionSet, v *models.TimestampType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TimestampType(ctx, sel, v)
}

func (ec *executionContext) marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2animeskipcombackendinternalgraphqlmodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithFieldInputContext(ctx, graphql.NewFieldInputWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, graphql.WrapErrorWithInputPath(ctx, err)
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAccount2animeskipcombackendinternalgraphqlmodelsAccount(ctx context.Context, sel ast.SelectionSet, v *models.Account) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx context.Context, sel ast.SelectionSet, v []*models.Episode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOEpisode2animeskipcombackendinternalgraphqlmodelsEpisode(ctx context.Context, sel ast.SelectionSet, v *models.Episode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Episode(ctx, sel, v)
}

func (ec *executionContext) marshalOEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx context.Context, sel ast.SelectionSet, v []*models.EpisodeURL) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOEpisodeUrl2animeskipcombackendinternalgraphqlmodelsEpisodeURL(ctx context.Context, sel ast.SelectionSet, v *models.EpisodeURL) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._EpisodeUrl(ctx, sel, v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalID(*v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*v)
}

func (ec *executionContext) marshalOLoginData2animeskipcombackendinternalgraphqlmodelsLoginData(ctx context.Context, sel ast.SelectionSet, v *models.LoginData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoginData(ctx, sel, v)
}

func (ec *executionContext) marshalOPreferences2animeskipcombackendinternalgraphqlmodelsPreferences(ctx context.Context, sel ast.SelectionSet, v *models.Preferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Preferences(ctx, sel, v)
}

func (ec *executionContext) marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx context.Context, sel ast.SelectionSet, v []*models.Show) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNShow2animeskipcombackendinternalgraphqlmodelsShow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOShow2animeskipcombackendinternalgraphqlmodelsShow(ctx context.Context, sel ast.SelectionSet, v *models.Show) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Show(ctx, sel, v)
}

func (ec *executionContext) marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx context.Context, sel ast.SelectionSet, v []*models.ShowAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOShowAdmin2animeskipcombackendinternalgraphqlmodelsShowAdmin(ctx context.Context, sel ast.SelectionSet, v *models.ShowAdmin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ShowAdmin(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOThirdPartyEpisode2animeskipcombackendinternalgraphqlmodelsThirdPartyEpisode(ctx context.Context, sel ast.SelectionSet, v []*models.ThirdPartyEpisode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOThirdPartyEpisode2animeskipcombackendinternalgraphqlmodelsThirdPartyEpisode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOThirdPartyEpisode2animeskipcombackendinternalgraphqlmodelsThirdPartyEpisode(ctx context.Context, sel ast.SelectionSet, v *models.ThirdPartyEpisode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ThirdPartyEpisode(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalTime(*v)
}

func (ec *executionContext) marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx context.Context, sel ast.SelectionSet, v []*models.Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTimestamp2animeskipcombackendinternalgraphqlmodelsTimestamp(ctx context.Context, sel ast.SelectionSet, v *models.Timestamp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Timestamp(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTimestampSource2animeskipcombackendinternalgraphqlmodelsTimestampSource(ctx context.Context, v interface{}) (*models.TimestampSource, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.TimestampSource)
	err := res.UnmarshalGQL(v)
	return res, graphql.WrapErrorWithInputPath(ctx, err)
}

func (ec *executionContext) marshalOTimestampSource2animeskipcombackendinternalgraphqlmodelsTimestampSource(ctx context.Context, sel ast.SelectionSet, v *models.TimestampSource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx context.Context, sel ast.SelectionSet, v []*models.TimestampType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTimestampType2animeskipcombackendinternalgraphqlmodelsTimestampType(ctx context.Context, sel ast.SelectionSet, v *models.TimestampType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TimestampType(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2animeskipcombackendinternalgraphqlmodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
