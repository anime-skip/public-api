// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/public-api/internal"
	context1 "anime-skip.com/public-api/internal/context"
	errors1 "anime-skip.com/public-api/internal/errors"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	"time"
)

func getEpisodeByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Episode, error) {
	var episode internal.Episode
	err := tx.GetContext(ctx, &episode, "SELECT * FROM episodes WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Episode{}, errors1.NewRecordNotFound(fmt.Sprintf("Episode.id=%s", id))
	}
	return episode, err
}

func getEpisodeByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Episode{}, err
	}
	defer tx.Rollback()

	result, err := getEpisodeByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Episode{}, err
	}

	tx.Commit()
	return result, nil
}

func getEpisodesByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.Episode, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episodes WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodes := []internal.Episode{}
	for rows.Next() {
		var episode internal.Episode
		err = rows.StructScan(&episode)
		if err != nil {
			return nil, err
		}
		episodes = append(episodes, episode)
	}
	return episodes, nil
}

func getEpisodesByShowID(ctx context.Context, db internal.Database, ShowID uuid.UUID) ([]internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getEpisodesByShowIDInTx(ctx, tx, ShowID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedEpisodesByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.Episode, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episodes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodes := []internal.Episode{}
	for rows.Next() {
		var episode internal.Episode
		err = rows.StructScan(&episode)
		if err != nil {
			return nil, err
		}
		episodes = append(episodes, episode)
	}
	return episodes, nil
}

func getUnscopedEpisodesByShowID(ctx context.Context, db internal.Database, ShowID uuid.UUID) ([]internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedEpisodesByShowIDInTx(ctx, tx, ShowID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func insertEpisodeInTx(ctx context.Context, tx internal.Tx, episode internal.Episode) (internal.Episode, error) {
	newEpisode := episode
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Episode{}, err
	}
	now := time.Now()
	newEpisode.CreatedAt = now
	newEpisode.CreatedByUserID = claims.UserID
	newEpisode.UpdatedAt = now
	newEpisode.UpdatedByUserID = claims.UserID
	newEpisode.DeletedAt = nil
	newEpisode.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO episodes(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, season, number, absolute_number, name, base_duration, show_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)",
		newEpisode.ID, newEpisode.CreatedAt, newEpisode.CreatedByUserID, newEpisode.UpdatedAt, newEpisode.UpdatedByUserID, newEpisode.DeletedAt, newEpisode.DeletedByUserID, newEpisode.Season, newEpisode.Number, newEpisode.AbsoluteNumber, newEpisode.Name, newEpisode.BaseDuration, newEpisode.ShowID,
	)
	if err != nil {
		return internal.Episode{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Episode{}, err
	}
	if changedRows != 1 {
		return internal.Episode{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newEpisode, err
}

func insertEpisode(ctx context.Context, db internal.Database, episode internal.Episode) (internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Episode{}, err
	}
	defer tx.Rollback()

	result, err := insertEpisodeInTx(ctx, tx, episode)
	if err != nil {
		return internal.Episode{}, err
	}

	tx.Commit()
	return result, nil
}

func updateEpisodeInTx(ctx context.Context, tx internal.Tx, inputEpisode internal.Episode) (internal.Episode, error) {
	updatedEpisode := inputEpisode
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Episode{}, err
	}
	now := time.Now()
	updatedEpisode.UpdatedAt = now
	updatedEpisode.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episodes SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, season=$7, number=$8, absolute_number=$9, name=$10, base_duration=$11, show_id=$12 WHERE id = $13",
		updatedEpisode.CreatedAt, updatedEpisode.CreatedByUserID, updatedEpisode.UpdatedAt, updatedEpisode.UpdatedByUserID, updatedEpisode.DeletedAt, updatedEpisode.DeletedByUserID, updatedEpisode.Season, updatedEpisode.Number, updatedEpisode.AbsoluteNumber, updatedEpisode.Name, updatedEpisode.BaseDuration, updatedEpisode.ShowID, updatedEpisode.ID,
	)
	if err != nil {
		return internal.Episode{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Episode{}, err
	}
	if changedRows != 1 {
		return internal.Episode{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisode, err
}

func updateEpisode(ctx context.Context, db internal.Database, episode internal.Episode) (internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Episode{}, err
	}
	defer tx.Rollback()

	result, err := updateEpisodeInTx(ctx, tx, episode)
	if err != nil {
		return internal.Episode{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteEpisodeInTx(ctx context.Context, tx internal.Tx, inputEpisode internal.Episode) (internal.Episode, error) {
	// Don't delete it if it's already deleted
	if inputEpisode.DeletedAt != nil && inputEpisode.DeletedByUserID != nil {
		return inputEpisode, nil
	}

	updatedEpisode := inputEpisode
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Episode{}, err
	}
	now := time.Now()
	updatedEpisode.UpdatedAt = now
	updatedEpisode.UpdatedByUserID = claims.UserID
	updatedEpisode.DeletedAt = &now
	updatedEpisode.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episodes SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, season=$7, number=$8, absolute_number=$9, name=$10, base_duration=$11, show_id=$12 WHERE id = $13",
		updatedEpisode.CreatedAt, updatedEpisode.CreatedByUserID, updatedEpisode.UpdatedAt, updatedEpisode.UpdatedByUserID, updatedEpisode.DeletedAt, updatedEpisode.DeletedByUserID, updatedEpisode.Season, updatedEpisode.Number, updatedEpisode.AbsoluteNumber, updatedEpisode.Name, updatedEpisode.BaseDuration, updatedEpisode.ShowID, updatedEpisode.ID,
	)
	if err != nil {
		return internal.Episode{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Episode{}, err
	}
	if changedRows != 1 {
		return internal.Episode{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisode, err
}
