// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/public-api/internal"
	context1 "anime-skip.com/public-api/internal/context"
	errors1 "anime-skip.com/public-api/internal/errors"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	"time"
)

func getTimestampTypeByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.TimestampType, error) {
	var timestampType internal.TimestampType
	err := tx.GetContext(ctx, &timestampType, "SELECT * FROM timestamp_types WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.TimestampType{}, errors1.NewRecordNotFound(fmt.Sprintf("TimestampType.id=%s", id))
	}
	return timestampType, err
}

func getTimestampTypeByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.TimestampType, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TimestampType{}, err
	}
	defer tx.Rollback()

	result, err := getTimestampTypeByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.TimestampType{}, err
	}

	tx.Commit()
	return result, nil
}

func insertTimestampTypeInTx(ctx context.Context, tx internal.Tx, timestampType internal.TimestampType) (internal.TimestampType, error) {
	newTimestampType := timestampType
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.TimestampType{}, err
	}
	now := time.Now()
	newTimestampType.CreatedAt = now
	newTimestampType.CreatedByUserID = claims.UserID
	newTimestampType.UpdatedAt = now
	newTimestampType.UpdatedByUserID = claims.UserID
	newTimestampType.DeletedAt = nil
	newTimestampType.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO timestamp_types(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, name, description) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newTimestampType.ID, newTimestampType.CreatedAt, newTimestampType.CreatedByUserID, newTimestampType.UpdatedAt, newTimestampType.UpdatedByUserID, newTimestampType.DeletedAt, newTimestampType.DeletedByUserID, newTimestampType.Name, newTimestampType.Description,
	)
	if err != nil {
		return internal.TimestampType{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TimestampType{}, err
	}
	if changedRows != 1 {
		return internal.TimestampType{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newTimestampType, err
}

func insertTimestampType(ctx context.Context, db internal.Database, timestampType internal.TimestampType) (internal.TimestampType, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TimestampType{}, err
	}
	defer tx.Rollback()

	result, err := insertTimestampTypeInTx(ctx, tx, timestampType)
	if err != nil {
		return internal.TimestampType{}, err
	}

	tx.Commit()
	return result, nil
}

func updateTimestampTypeInTx(ctx context.Context, tx internal.Tx, inputTimestampType internal.TimestampType) (internal.TimestampType, error) {
	updatedTimestampType := inputTimestampType
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.TimestampType{}, err
	}
	now := time.Now()
	updatedTimestampType.UpdatedAt = now
	updatedTimestampType.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamp_types SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, name=$7, description=$8 WHERE id = $9",
		updatedTimestampType.CreatedAt, updatedTimestampType.CreatedByUserID, updatedTimestampType.UpdatedAt, updatedTimestampType.UpdatedByUserID, updatedTimestampType.DeletedAt, updatedTimestampType.DeletedByUserID, updatedTimestampType.Name, updatedTimestampType.Description, updatedTimestampType.ID,
	)
	if err != nil {
		return internal.TimestampType{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TimestampType{}, err
	}
	if changedRows != 1 {
		return internal.TimestampType{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestampType, err
}

func updateTimestampType(ctx context.Context, db internal.Database, timestampType internal.TimestampType) (internal.TimestampType, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TimestampType{}, err
	}
	defer tx.Rollback()

	result, err := updateTimestampTypeInTx(ctx, tx, timestampType)
	if err != nil {
		return internal.TimestampType{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteTimestampTypeInTx(ctx context.Context, tx internal.Tx, inputTimestampType internal.TimestampType) (internal.TimestampType, error) {
	// Don't delete it if it's already deleted
	if inputTimestampType.DeletedAt != nil && inputTimestampType.DeletedByUserID != nil {
		return inputTimestampType, nil
	}

	updatedTimestampType := inputTimestampType
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.TimestampType{}, err
	}
	now := time.Now()
	updatedTimestampType.UpdatedAt = now
	updatedTimestampType.UpdatedByUserID = claims.UserID
	updatedTimestampType.DeletedAt = &now
	updatedTimestampType.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamp_types SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, name=$7, description=$8 WHERE id = $9",
		updatedTimestampType.CreatedAt, updatedTimestampType.CreatedByUserID, updatedTimestampType.UpdatedAt, updatedTimestampType.UpdatedByUserID, updatedTimestampType.DeletedAt, updatedTimestampType.DeletedByUserID, updatedTimestampType.Name, updatedTimestampType.Description, updatedTimestampType.ID,
	)
	if err != nil {
		return internal.TimestampType{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TimestampType{}, err
	}
	if changedRows != 1 {
		return internal.TimestampType{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestampType, err
}
