// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/timestamps-service/internal"
	context1 "anime-skip.com/timestamps-service/internal/context"
	errors1 "anime-skip.com/timestamps-service/internal/errors"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	"time"
)

func getEpisodeURLByURLInTx(ctx context.Context, tx internal.Tx, url string) (internal.EpisodeURL, error) {
	var episodeURL internal.EpisodeURL
	err := tx.GetContext(ctx, &episodeURL, "SELECT * FROM episode_urls WHERE url=$1", url)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.EpisodeURL{}, errors1.NewRecordNotFound(fmt.Sprintf("EpisodeURL.url=%s", url))
	}
	return episodeURL, err
}

func getEpisodeURLByURL(ctx context.Context, db internal.Database, URL string) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := getEpisodeURLByURLInTx(ctx, tx, URL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

func getEpisodeURLsByEpisodeIDInTx(ctx context.Context, tx internal.Tx, episodeID uuid.UUID) ([]internal.EpisodeURL, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episode_urls")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodeURLs := []internal.EpisodeURL{}
	for rows.Next() {
		var episodeURL internal.EpisodeURL
		err = rows.StructScan(&episodeURL)
		if err != nil {
			return nil, err
		}
		episodeURLs = append(episodeURLs, episodeURL)
	}
	return episodeURLs, nil
}

func getEpisodeURLsByEpisodeID(ctx context.Context, db internal.Database, EpisodeID uuid.UUID) ([]internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getEpisodeURLsByEpisodeIDInTx(ctx, tx, EpisodeID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func insertEpisodeURLInTx(ctx context.Context, tx internal.Tx, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	newEpisodeURL := episodeURL
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	now := time.Now()
	newEpisodeURL.CreatedAt = now
	newEpisodeURL.CreatedByUserID = claims.UserID
	newEpisodeURL.UpdatedAt = now
	newEpisodeURL.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO episode_urls(url, created_at, created_by_user_id, updated_at, updated_by_user_id, source, duration, timestamps_offset, episode_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newEpisodeURL.URL, newEpisodeURL.CreatedAt, newEpisodeURL.CreatedByUserID, newEpisodeURL.UpdatedAt, newEpisodeURL.UpdatedByUserID, newEpisodeURL.Source, newEpisodeURL.Duration, newEpisodeURL.TimestampsOffset, newEpisodeURL.EpisodeID,
	)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newEpisodeURL, err
}

func insertEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := insertEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

func updateEpisodeURLInTx(ctx context.Context, tx internal.Tx, newEpisodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	updatedEpisodeURL := newEpisodeURL
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	now := time.Now()
	updatedEpisodeURL.UpdatedAt = now
	updatedEpisodeURL.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episode_urls SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, source=$5, duration=$6, timestamps_offset=$7, episode_id=$8 WHERE url = $9",
		updatedEpisodeURL.CreatedAt, updatedEpisodeURL.CreatedByUserID, updatedEpisodeURL.UpdatedAt, updatedEpisodeURL.UpdatedByUserID, updatedEpisodeURL.Source, updatedEpisodeURL.Duration, updatedEpisodeURL.TimestampsOffset, updatedEpisodeURL.EpisodeID, updatedEpisodeURL.URL,
	)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisodeURL, err
}

func updateEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := updateEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

// Hard delete the EpisodeURL. It requires the entire model be passed in so that you have it before calling this function, and can return the value if needed
func deleteEpisodeURLInTx(ctx context.Context, tx internal.Tx, episodeURL internal.EpisodeURL) error {
	result, err := tx.ExecContext(ctx, "DELETE FROM episode_urls WHERE url=$1", episodeURL.URL)
	if err != nil {
		return err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if changedRows != 1 {
		return fmt.Errorf("Deleted more than 1 row (%d)", changedRows)
	}
	return err
}
