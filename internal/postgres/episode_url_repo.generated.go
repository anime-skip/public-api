// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/timestamps-service/internal"
	context1 "anime-skip.com/timestamps-service/internal/context"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	sqlx "github.com/jmoiron/sqlx"
	"time"
)

func getEpisodeURLByURL(ctx context.Context, db internal.Database, url string) (internal.EpisodeURL, error) {
	var episodeURL internal.EpisodeURL
	err := db.GetContext(ctx, &episodeURL, "SELECT * FROM episode_urls WHERE url=$1", url)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.EpisodeURL{}, errors.New("record not found")
	}
	return episodeURL, err
}

func getEpisodeURLsByEpisodeID(ctx context.Context, db internal.Database, episodeID uuid.UUID) ([]internal.EpisodeURL, error) {
	rows, err := db.QueryxContext(ctx, "SELECT * FROM episode_urls")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodeURLs := []internal.EpisodeURL{}
	for rows.Next() {
		var episodeURL internal.EpisodeURL
		err = rows.StructScan(&episodeURL)
		if err != nil {
			return nil, err
		}
		episodeURLs = append(episodeURLs, episodeURL)
	}
	return episodeURLs, nil
}

func insertEpisodeURLInTx(ctx context.Context, tx *sqlx.Tx, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	newEpisodeURL := episodeURL
	auth, err := context1.GetAuthenticationDetails(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	newEpisodeURL.CreatedAt = time.Now()
	newEpisodeURL.CreatedByUserID = auth.UserID
	newEpisodeURL.UpdatedAt = time.Now()
	newEpisodeURL.UpdatedByUserID = auth.UserID
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO episode_urls(url, created_at, created_by_user_id, updated_at, updated_by_user_id, source, duration, timestamps_offset, episode_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newEpisodeURL.URL, newEpisodeURL.CreatedAt, newEpisodeURL.CreatedByUserID, newEpisodeURL.UpdatedAt, newEpisodeURL.UpdatedByUserID, newEpisodeURL.Source, newEpisodeURL.Duration, newEpisodeURL.TimestampsOffset, newEpisodeURL.EpisodeID,
	)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newEpisodeURL, err
}

func insertEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := insertEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

func updateEpisodeURLInTx(ctx context.Context, tx *sqlx.Tx, newEpisodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	updatedEpisodeURL := newEpisodeURL
	auth, err := context1.GetAuthenticationDetails(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	updatedEpisodeURL.UpdatedAt = time.Now()
	updatedEpisodeURL.UpdatedByUserID = auth.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episode_urls SET url=$1, created_at=$2, created_by_user_id=$3, updated_at=$4, updated_by_user_id=$5, source=$6, duration=$7, timestamps_offset=$8, episode_id=$9",
		updatedEpisodeURL.URL, updatedEpisodeURL.CreatedAt, updatedEpisodeURL.CreatedByUserID, updatedEpisodeURL.UpdatedAt, updatedEpisodeURL.UpdatedByUserID, updatedEpisodeURL.Source, updatedEpisodeURL.Duration, updatedEpisodeURL.TimestampsOffset, updatedEpisodeURL.EpisodeID,
	)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisodeURL, err
}

func updateEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := updateEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteEpisodeURLInTx(ctx context.Context, tx *sqlx.Tx, newEpisodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	deletedEpisodeURL := newEpisodeURL
	auth, err := context1.GetAuthenticationDetails(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	deletedEpisodeURL.UpdatedAt = time.Now()
	deletedEpisodeURL.UpdatedByUserID = auth.UserID
	result, err := tx.ExecContext(ctx, "DELETE FROM episode_urls WHERE url=$1", deletedEpisodeURL.URL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Deleted more than 1 row (%d)", changedRows)
	}
	return deletedEpisodeURL, err
}

func deleteEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := deleteEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}
