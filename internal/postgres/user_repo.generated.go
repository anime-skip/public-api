// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/public-api/internal"
	errors1 "anime-skip.com/public-api/internal/errors"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	"time"
)

func getUserByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.id=%s", id))
	}
	return user, err
}

func getUserByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUserByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUserByUsernameInTx(ctx context.Context, tx internal.Tx, username string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE username=$1 AND deleted_at IS NULL", username)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.username=%s", username))
	}
	return user, err
}

func getUserByUsername(ctx context.Context, db internal.Database, Username string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUserByUsernameInTx(ctx, tx, Username)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedUserByUsernameInTx(ctx context.Context, tx internal.Tx, username string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE username=$1", username)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.username=%s", username))
	}
	return user, err
}

func getUnscopedUserByUsername(ctx context.Context, db internal.Database, Username string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUnscopedUserByUsernameInTx(ctx, tx, Username)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUserByEmailInTx(ctx context.Context, tx internal.Tx, email string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE email=$1 AND deleted_at IS NULL", email)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.email=%s", email))
	}
	return user, err
}

func getUserByEmail(ctx context.Context, db internal.Database, Email string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUserByEmailInTx(ctx, tx, Email)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedUserByEmailInTx(ctx context.Context, tx internal.Tx, email string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE email=$1", email)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.email=%s", email))
	}
	return user, err
}

func getUnscopedUserByEmail(ctx context.Context, db internal.Database, Email string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUnscopedUserByEmailInTx(ctx, tx, Email)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func insertUserInTx(ctx context.Context, tx internal.Tx, user internal.User) (internal.User, error) {
	newUser := user
	now := time.Now()
	newUser.CreatedAt = now
	newUser.DeletedAt = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO users(id, created_at, deleted_at, username, email, password_hash, profile_url, email_verified, role) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newUser.ID, newUser.CreatedAt, newUser.DeletedAt, newUser.Username, newUser.Email, newUser.PasswordHash, newUser.ProfileURL, newUser.EmailVerified, newUser.Role,
	)
	if err != nil {
		return internal.User{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.User{}, err
	}
	if changedRows != 1 {
		return internal.User{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newUser, err
}

func insertUser(ctx context.Context, db internal.Database, user internal.User) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := insertUserInTx(ctx, tx, user)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func updateUserInTx(ctx context.Context, tx internal.Tx, inputUser internal.User) (internal.User, error) {
	updatedUser := inputUser
	result, err := tx.ExecContext(
		ctx,
		"UPDATE users SET created_at=$1, deleted_at=$2, username=$3, email=$4, password_hash=$5, profile_url=$6, email_verified=$7, role=$8 WHERE id = $9",
		updatedUser.CreatedAt, updatedUser.DeletedAt, updatedUser.Username, updatedUser.Email, updatedUser.PasswordHash, updatedUser.ProfileURL, updatedUser.EmailVerified, updatedUser.Role, updatedUser.ID,
	)
	if err != nil {
		return internal.User{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.User{}, err
	}
	if changedRows != 1 {
		return internal.User{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedUser, err
}

func updateUser(ctx context.Context, db internal.Database, user internal.User) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := updateUserInTx(ctx, tx, user)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteUserInTx(ctx context.Context, tx internal.Tx, inputUser internal.User) (internal.User, error) {
	// Don't delete it if it's already deleted
	if inputUser.DeletedAt != nil {
		return inputUser, nil
	}

	updatedUser := inputUser
	now := time.Now()
	updatedUser.DeletedAt = &now
	result, err := tx.ExecContext(
		ctx,
		"UPDATE users SET created_at=$1, deleted_at=$2, username=$3, email=$4, password_hash=$5, profile_url=$6, email_verified=$7, role=$8 WHERE id = $9",
		updatedUser.CreatedAt, updatedUser.DeletedAt, updatedUser.Username, updatedUser.Email, updatedUser.PasswordHash, updatedUser.ProfileURL, updatedUser.EmailVerified, updatedUser.Role, updatedUser.ID,
	)
	if err != nil {
		return internal.User{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.User{}, err
	}
	if changedRows != 1 {
		return internal.User{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedUser, err
}
