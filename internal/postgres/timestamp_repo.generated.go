// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/timestamps-service/internal"
	context1 "anime-skip.com/timestamps-service/internal/context"
	errors1 "anime-skip.com/timestamps-service/internal/errors"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	"time"
)

func getTimestampByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Timestamp, error) {
	var timestamp internal.Timestamp
	err := tx.GetContext(ctx, &timestamp, "SELECT * FROM timestamps WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Timestamp{}, errors1.NewRecordNotFound(fmt.Sprintf("Timestamp.id=%s", id))
	}
	return timestamp, err
}

func getTimestampByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Timestamp{}, err
	}
	defer tx.Rollback()

	result, err := getTimestampByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Timestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func getTimestampsByEpisodeIDInTx(ctx context.Context, tx internal.Tx, episodeID uuid.UUID) ([]internal.Timestamp, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM timestamps WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	timestamps := []internal.Timestamp{}
	for rows.Next() {
		var timestamp internal.Timestamp
		err = rows.StructScan(&timestamp)
		if err != nil {
			return nil, err
		}
		timestamps = append(timestamps, timestamp)
	}
	return timestamps, nil
}

func getTimestampsByEpisodeID(ctx context.Context, db internal.Database, EpisodeID uuid.UUID) ([]internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getTimestampsByEpisodeIDInTx(ctx, tx, EpisodeID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedTimestampsByEpisodeIDInTx(ctx context.Context, tx internal.Tx, episodeID uuid.UUID) ([]internal.Timestamp, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM timestamps")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	timestamps := []internal.Timestamp{}
	for rows.Next() {
		var timestamp internal.Timestamp
		err = rows.StructScan(&timestamp)
		if err != nil {
			return nil, err
		}
		timestamps = append(timestamps, timestamp)
	}
	return timestamps, nil
}

func getUnscopedTimestampsByEpisodeID(ctx context.Context, db internal.Database, EpisodeID uuid.UUID) ([]internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedTimestampsByEpisodeIDInTx(ctx, tx, EpisodeID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func insertTimestampInTx(ctx context.Context, tx internal.Tx, timestamp internal.Timestamp) (internal.Timestamp, error) {
	newTimestamp := timestamp
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Timestamp{}, err
	}
	now := time.Now()
	newTimestamp.CreatedAt = now
	newTimestamp.CreatedByUserID = claims.UserID
	newTimestamp.UpdatedAt = now
	newTimestamp.UpdatedByUserID = claims.UserID
	newTimestamp.DeletedAt = nil
	newTimestamp.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO timestamps(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, at, source, type_id, episode_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)",
		newTimestamp.ID, newTimestamp.CreatedAt, newTimestamp.CreatedByUserID, newTimestamp.UpdatedAt, newTimestamp.UpdatedByUserID, newTimestamp.DeletedAt, newTimestamp.DeletedByUserID, newTimestamp.At, newTimestamp.Source, newTimestamp.TypeID, newTimestamp.EpisodeID,
	)
	if err != nil {
		return internal.Timestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Timestamp{}, err
	}
	if changedRows != 1 {
		return internal.Timestamp{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newTimestamp, err
}

func insertTimestamp(ctx context.Context, db internal.Database, timestamp internal.Timestamp) (internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Timestamp{}, err
	}
	defer tx.Rollback()

	result, err := insertTimestampInTx(ctx, tx, timestamp)
	if err != nil {
		return internal.Timestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func updateTimestampInTx(ctx context.Context, tx internal.Tx, inputTimestamp internal.Timestamp) (internal.Timestamp, error) {
	updatedTimestamp := inputTimestamp
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Timestamp{}, err
	}
	now := time.Now()
	updatedTimestamp.UpdatedAt = now
	updatedTimestamp.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamps SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, at=$7, source=$8, type_id=$9, episode_id=$10 WHERE id = $11",
		updatedTimestamp.CreatedAt, updatedTimestamp.CreatedByUserID, updatedTimestamp.UpdatedAt, updatedTimestamp.UpdatedByUserID, updatedTimestamp.DeletedAt, updatedTimestamp.DeletedByUserID, updatedTimestamp.At, updatedTimestamp.Source, updatedTimestamp.TypeID, updatedTimestamp.EpisodeID, updatedTimestamp.ID,
	)
	if err != nil {
		return internal.Timestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Timestamp{}, err
	}
	if changedRows != 1 {
		return internal.Timestamp{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestamp, err
}

func updateTimestamp(ctx context.Context, db internal.Database, timestamp internal.Timestamp) (internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Timestamp{}, err
	}
	defer tx.Rollback()

	result, err := updateTimestampInTx(ctx, tx, timestamp)
	if err != nil {
		return internal.Timestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteTimestampInTx(ctx context.Context, tx internal.Tx, inputTimestamp internal.Timestamp) (internal.Timestamp, error) {
	// Don't delete it if it's already deleted
	if inputTimestamp.DeletedAt != nil && inputTimestamp.DeletedByUserID != nil {
		return inputTimestamp, nil
	}

	updatedTimestamp := inputTimestamp
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Timestamp{}, err
	}
	now := time.Now()
	updatedTimestamp.UpdatedAt = now
	updatedTimestamp.UpdatedByUserID = claims.UserID
	updatedTimestamp.DeletedAt = &now
	updatedTimestamp.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamps SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, at=$7, source=$8, type_id=$9, episode_id=$10 WHERE id = $11",
		updatedTimestamp.CreatedAt, updatedTimestamp.CreatedByUserID, updatedTimestamp.UpdatedAt, updatedTimestamp.UpdatedByUserID, updatedTimestamp.DeletedAt, updatedTimestamp.DeletedByUserID, updatedTimestamp.At, updatedTimestamp.Source, updatedTimestamp.TypeID, updatedTimestamp.EpisodeID, updatedTimestamp.ID,
	)
	if err != nil {
		return internal.Timestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Timestamp{}, err
	}
	if changedRows != 1 {
		return internal.Timestamp{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestamp, err
}
