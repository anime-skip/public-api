// Code generated by cmd/sqlgen/main.go, DO NOT EDIT.

package postgres

import (
	internal "anime-skip.com/public-api/internal"
	context1 "anime-skip.com/public-api/internal/context"
	errors1 "anime-skip.com/public-api/internal/errors"
	"context"
	"database/sql"
	"errors"
	"fmt"
	uuid "github.com/gofrs/uuid"
	"strings"
	"time"
)

// Search types

type WhereCondition interface {
	condition(argNumber int) string
	arg() interface{}
}

type LimitOffset struct {
	Limit  int
	Offset int
}

type OrderBy struct {
	Column    string
	Direction string
}

type WhereGT struct {
	column string
	value  interface{}
}

func (w WhereGT) condition(argNumber int) string {
	return fmt.Sprintf("%s %s $%d", w.column, ">", argNumber)
}
func (w WhereGT) arg() interface{} {
	return w.value
}

type WhereGTE struct {
	column string
	value  interface{}
}

func (w WhereGTE) condition(argNumber int) string {
	return fmt.Sprintf("%s %s $%d", w.column, ">=", argNumber)
}
func (w WhereGTE) arg() interface{} {
	return w.value
}

type WhereLT struct {
	column string
	value  interface{}
}

func (w WhereLT) condition(argNumber int) string {
	return fmt.Sprintf("%s %s $%d", w.column, "<", argNumber)
}
func (w WhereLT) arg() interface{} {
	return w.value
}

type WhereLTE struct {
	column string
	value  interface{}
}

func (w WhereLTE) condition(argNumber int) string {
	return fmt.Sprintf("%s %s $%d", w.column, "<=", argNumber)
}
func (w WhereLTE) arg() interface{} {
	return w.value
}

type WhereEqual struct {
	column string
	value  interface{}
}

func (w WhereEqual) condition(argNumber int) string {
	return fmt.Sprintf("%s %s $%d", w.column, "=", argNumber)
}
func (w WhereEqual) arg() interface{} {
	return w.value
}

type WhereLike struct {
	column     string
	value      string
	ignoreCase bool
}

func (w WhereLike) condition(argNumber int) string {
	like := "LIKE"
	if w.ignoreCase {
		like = "ILIKE"
	}
	return fmt.Sprintf("%s %s $%d", w.column, like, argNumber)
}
func (w WhereLike) arg() interface{} {
	return w.value
}

// APIClient

func getAPIClientByIDInTx(ctx context.Context, tx internal.Tx, id string) (internal.APIClient, error) {
	var apiClient internal.APIClient
	err := tx.GetContext(ctx, &apiClient, "SELECT * FROM api_clients WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.APIClient{}, errors1.NewRecordNotFound(fmt.Sprintf("APIClient.id=%s", id))
	}
	return apiClient, err
}

func getAPIClientByID(ctx context.Context, db internal.Database, ID string) (internal.APIClient, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.APIClient{}, err
	}
	defer tx.Rollback()

	result, err := getAPIClientByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.APIClient{}, err
	}

	tx.Commit()
	return result, nil
}

func getAPIClientsByUserIDInTx(ctx context.Context, tx internal.Tx, userID uuid.UUID) ([]internal.APIClient, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM api_clients WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	apiClients := []internal.APIClient{}
	for rows.Next() {
		var apiClient internal.APIClient
		err = rows.StructScan(&apiClient)
		if err != nil {
			return nil, err
		}
		apiClients = append(apiClients, apiClient)
	}
	return apiClients, nil
}

func getAPIClientsByUserID(ctx context.Context, db internal.Database, userID uuid.UUID) ([]internal.APIClient, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getAPIClientsByUserIDInTx(ctx, tx, userID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedAPIClientsByUserIDInTx(ctx context.Context, tx internal.Tx, userID uuid.UUID) ([]internal.APIClient, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM api_clients")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	apiClients := []internal.APIClient{}
	for rows.Next() {
		var apiClient internal.APIClient
		err = rows.StructScan(&apiClient)
		if err != nil {
			return nil, err
		}
		apiClients = append(apiClients, apiClient)
	}
	return apiClients, nil
}

func getUnscopedAPIClientsByUserID(ctx context.Context, db internal.Database, userID uuid.UUID) ([]internal.APIClient, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedAPIClientsByUserIDInTx(ctx, tx, userID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchAPIClients(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.APIClient, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, user_id, app_name, description, allowed_origins, rate_limit_rpm FROM api_clients")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.APIClient{}
	for rows.Next() {
		var row internal.APIClient
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertAPIClientInTx(ctx context.Context, tx internal.Tx, apiClient internal.APIClient) (internal.APIClient, error) {
	newAPIClient := apiClient
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.APIClient{}, err
	}
	now := time.Now()
	newAPIClient.CreatedAt = now
	newAPIClient.CreatedByUserID = claims.UserID
	newAPIClient.UpdatedAt = now
	newAPIClient.UpdatedByUserID = claims.UserID
	newAPIClient.DeletedAt = nil
	newAPIClient.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO api_clients(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, user_id, app_name, description, allowed_origins, rate_limit_rpm) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)",
		newAPIClient.ID, newAPIClient.CreatedAt, newAPIClient.CreatedByUserID, newAPIClient.UpdatedAt, newAPIClient.UpdatedByUserID, newAPIClient.DeletedAt, newAPIClient.DeletedByUserID, newAPIClient.UserID, newAPIClient.AppName, newAPIClient.Description, newAPIClient.AllowedOrigins, newAPIClient.RateLimitRPM,
	)
	if err != nil {
		return internal.APIClient{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.APIClient{}, err
	}
	if changedRows != 1 {
		return internal.APIClient{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newAPIClient, err
}

func insertAPIClient(ctx context.Context, db internal.Database, apiClient internal.APIClient) (internal.APIClient, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.APIClient{}, err
	}
	defer tx.Rollback()

	result, err := insertAPIClientInTx(ctx, tx, apiClient)
	if err != nil {
		return internal.APIClient{}, err
	}

	tx.Commit()
	return result, nil
}

func updateAPIClientInTx(ctx context.Context, tx internal.Tx, inputAPIClient internal.APIClient) (internal.APIClient, error) {
	updatedAPIClient := inputAPIClient
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.APIClient{}, err
	}
	now := time.Now()
	updatedAPIClient.UpdatedAt = now
	updatedAPIClient.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE api_clients SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, user_id=$7, app_name=$8, description=$9, allowed_origins=$10, rate_limit_rpm=$11 WHERE id = $12",
		updatedAPIClient.CreatedAt, updatedAPIClient.CreatedByUserID, updatedAPIClient.UpdatedAt, updatedAPIClient.UpdatedByUserID, updatedAPIClient.DeletedAt, updatedAPIClient.DeletedByUserID, updatedAPIClient.UserID, updatedAPIClient.AppName, updatedAPIClient.Description, updatedAPIClient.AllowedOrigins, updatedAPIClient.RateLimitRPM, updatedAPIClient.ID,
	)
	if err != nil {
		return internal.APIClient{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.APIClient{}, err
	}
	if changedRows != 1 {
		return internal.APIClient{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedAPIClient, err
}

func updateAPIClient(ctx context.Context, db internal.Database, apiClient internal.APIClient) (internal.APIClient, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.APIClient{}, err
	}
	defer tx.Rollback()

	result, err := updateAPIClientInTx(ctx, tx, apiClient)
	if err != nil {
		return internal.APIClient{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteAPIClientInTx(ctx context.Context, tx internal.Tx, inputAPIClient internal.APIClient) (internal.APIClient, error) {
	// Don't delete it if it's already deleted
	if inputAPIClient.DeletedAt != nil && inputAPIClient.DeletedByUserID != nil {
		return inputAPIClient, nil
	}

	updatedAPIClient := inputAPIClient
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.APIClient{}, err
	}
	now := time.Now()
	updatedAPIClient.UpdatedAt = now
	updatedAPIClient.UpdatedByUserID = claims.UserID
	updatedAPIClient.DeletedAt = &now
	updatedAPIClient.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE api_clients SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, user_id=$7, app_name=$8, description=$9, allowed_origins=$10, rate_limit_rpm=$11 WHERE id = $12",
		updatedAPIClient.CreatedAt, updatedAPIClient.CreatedByUserID, updatedAPIClient.UpdatedAt, updatedAPIClient.UpdatedByUserID, updatedAPIClient.DeletedAt, updatedAPIClient.DeletedByUserID, updatedAPIClient.UserID, updatedAPIClient.AppName, updatedAPIClient.Description, updatedAPIClient.AllowedOrigins, updatedAPIClient.RateLimitRPM, updatedAPIClient.ID,
	)
	if err != nil {
		return internal.APIClient{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.APIClient{}, err
	}
	if changedRows != 1 {
		return internal.APIClient{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedAPIClient, err
}

// EpisodeURL

func getEpisodeURLByURLInTx(ctx context.Context, tx internal.Tx, url string) (internal.EpisodeURL, error) {
	var episodeURL internal.EpisodeURL
	err := tx.GetContext(ctx, &episodeURL, "SELECT * FROM episode_urls WHERE url=$1", url)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.EpisodeURL{}, errors1.NewRecordNotFound(fmt.Sprintf("EpisodeURL.url=%s", url))
	}
	return episodeURL, err
}

func getEpisodeURLByURL(ctx context.Context, db internal.Database, URL string) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := getEpisodeURLByURLInTx(ctx, tx, URL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

func getEpisodeURLsByEpisodeIDInTx(ctx context.Context, tx internal.Tx, episodeID uuid.UUID) ([]internal.EpisodeURL, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episode_urls")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodeURLs := []internal.EpisodeURL{}
	for rows.Next() {
		var episodeURL internal.EpisodeURL
		err = rows.StructScan(&episodeURL)
		if err != nil {
			return nil, err
		}
		episodeURLs = append(episodeURLs, episodeURL)
	}
	return episodeURLs, nil
}

func getEpisodeURLsByEpisodeID(ctx context.Context, db internal.Database, episodeID uuid.UUID) ([]internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getEpisodeURLsByEpisodeIDInTx(ctx, tx, episodeID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchEpisodeURLs(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.EpisodeURL, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT url, created_at, created_by_user_id, updated_at, updated_by_user_id, source, duration, timestamps_offset, episode_id FROM episode_urls")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.EpisodeURL{}
	for rows.Next() {
		var row internal.EpisodeURL
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertEpisodeURLInTx(ctx context.Context, tx internal.Tx, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	newEpisodeURL := episodeURL
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	now := time.Now()
	newEpisodeURL.CreatedAt = now
	newEpisodeURL.CreatedByUserID = claims.UserID
	newEpisodeURL.UpdatedAt = now
	newEpisodeURL.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO episode_urls(url, created_at, created_by_user_id, updated_at, updated_by_user_id, source, duration, timestamps_offset, episode_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newEpisodeURL.URL, newEpisodeURL.CreatedAt, newEpisodeURL.CreatedByUserID, newEpisodeURL.UpdatedAt, newEpisodeURL.UpdatedByUserID, newEpisodeURL.Source, newEpisodeURL.Duration, newEpisodeURL.TimestampsOffset, newEpisodeURL.EpisodeID,
	)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newEpisodeURL, err
}

func insertEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := insertEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

func updateEpisodeURLInTx(ctx context.Context, tx internal.Tx, inputEpisodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	updatedEpisodeURL := inputEpisodeURL
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	now := time.Now()
	updatedEpisodeURL.UpdatedAt = now
	updatedEpisodeURL.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episode_urls SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, source=$5, duration=$6, timestamps_offset=$7, episode_id=$8 WHERE url = $9",
		updatedEpisodeURL.CreatedAt, updatedEpisodeURL.CreatedByUserID, updatedEpisodeURL.UpdatedAt, updatedEpisodeURL.UpdatedByUserID, updatedEpisodeURL.Source, updatedEpisodeURL.Duration, updatedEpisodeURL.TimestampsOffset, updatedEpisodeURL.EpisodeID, updatedEpisodeURL.URL,
	)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	if changedRows != 1 {
		return internal.EpisodeURL{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisodeURL, err
}

func updateEpisodeURL(ctx context.Context, db internal.Database, episodeURL internal.EpisodeURL) (internal.EpisodeURL, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.EpisodeURL{}, err
	}
	defer tx.Rollback()

	result, err := updateEpisodeURLInTx(ctx, tx, episodeURL)
	if err != nil {
		return internal.EpisodeURL{}, err
	}

	tx.Commit()
	return result, nil
}

// Hard delete the EpisodeURL. It requires the entire model be passed in so that you have it before calling this function, and can return the value if needed
func deleteEpisodeURLInTx(ctx context.Context, tx internal.Tx, episodeURL internal.EpisodeURL) error {
	result, err := tx.ExecContext(ctx, "DELETE FROM episode_urls WHERE url=$1", episodeURL.URL)
	if err != nil {
		return err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if changedRows != 1 {
		return fmt.Errorf("Deleted more than 1 row (%d)", changedRows)
	}
	return err
}

// Episode

func getEpisodeByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Episode, error) {
	var episode internal.Episode
	err := tx.GetContext(ctx, &episode, "SELECT * FROM episodes WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Episode{}, errors1.NewRecordNotFound(fmt.Sprintf("Episode.id=%s", id))
	}
	return episode, err
}

func getEpisodeByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Episode{}, err
	}
	defer tx.Rollback()

	result, err := getEpisodeByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Episode{}, err
	}

	tx.Commit()
	return result, nil
}

func getEpisodesByNameInTx(ctx context.Context, tx internal.Tx, name *string) ([]internal.Episode, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episodes WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodes := []internal.Episode{}
	for rows.Next() {
		var episode internal.Episode
		err = rows.StructScan(&episode)
		if err != nil {
			return nil, err
		}
		episodes = append(episodes, episode)
	}
	return episodes, nil
}

func getEpisodesByName(ctx context.Context, db internal.Database, name *string) ([]internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getEpisodesByNameInTx(ctx, tx, name)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedEpisodesByNameInTx(ctx context.Context, tx internal.Tx, name *string) ([]internal.Episode, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episodes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodes := []internal.Episode{}
	for rows.Next() {
		var episode internal.Episode
		err = rows.StructScan(&episode)
		if err != nil {
			return nil, err
		}
		episodes = append(episodes, episode)
	}
	return episodes, nil
}

func getUnscopedEpisodesByName(ctx context.Context, db internal.Database, name *string) ([]internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedEpisodesByNameInTx(ctx, tx, name)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getEpisodesByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.Episode, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episodes WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodes := []internal.Episode{}
	for rows.Next() {
		var episode internal.Episode
		err = rows.StructScan(&episode)
		if err != nil {
			return nil, err
		}
		episodes = append(episodes, episode)
	}
	return episodes, nil
}

func getEpisodesByShowID(ctx context.Context, db internal.Database, showID uuid.UUID) ([]internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getEpisodesByShowIDInTx(ctx, tx, showID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedEpisodesByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.Episode, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM episodes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	episodes := []internal.Episode{}
	for rows.Next() {
		var episode internal.Episode
		err = rows.StructScan(&episode)
		if err != nil {
			return nil, err
		}
		episodes = append(episodes, episode)
	}
	return episodes, nil
}

func getUnscopedEpisodesByShowID(ctx context.Context, db internal.Database, showID uuid.UUID) ([]internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedEpisodesByShowIDInTx(ctx, tx, showID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchEpisodes(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.Episode, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, season, number, absolute_number, name, base_duration, show_id FROM episodes")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.Episode{}
	for rows.Next() {
		var row internal.Episode
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertEpisodeInTx(ctx context.Context, tx internal.Tx, episode internal.Episode) (internal.Episode, error) {
	newEpisode := episode
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Episode{}, err
	}
	now := time.Now()
	newEpisode.CreatedAt = now
	newEpisode.CreatedByUserID = claims.UserID
	newEpisode.UpdatedAt = now
	newEpisode.UpdatedByUserID = claims.UserID
	newEpisode.DeletedAt = nil
	newEpisode.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO episodes(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, season, number, absolute_number, name, base_duration, show_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)",
		newEpisode.ID, newEpisode.CreatedAt, newEpisode.CreatedByUserID, newEpisode.UpdatedAt, newEpisode.UpdatedByUserID, newEpisode.DeletedAt, newEpisode.DeletedByUserID, newEpisode.Season, newEpisode.Number, newEpisode.AbsoluteNumber, newEpisode.Name, newEpisode.BaseDuration, newEpisode.ShowID,
	)
	if err != nil {
		return internal.Episode{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Episode{}, err
	}
	if changedRows != 1 {
		return internal.Episode{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newEpisode, err
}

func insertEpisode(ctx context.Context, db internal.Database, episode internal.Episode) (internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Episode{}, err
	}
	defer tx.Rollback()

	result, err := insertEpisodeInTx(ctx, tx, episode)
	if err != nil {
		return internal.Episode{}, err
	}

	tx.Commit()
	return result, nil
}

func updateEpisodeInTx(ctx context.Context, tx internal.Tx, inputEpisode internal.Episode) (internal.Episode, error) {
	updatedEpisode := inputEpisode
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Episode{}, err
	}
	now := time.Now()
	updatedEpisode.UpdatedAt = now
	updatedEpisode.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episodes SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, season=$7, number=$8, absolute_number=$9, name=$10, base_duration=$11, show_id=$12 WHERE id = $13",
		updatedEpisode.CreatedAt, updatedEpisode.CreatedByUserID, updatedEpisode.UpdatedAt, updatedEpisode.UpdatedByUserID, updatedEpisode.DeletedAt, updatedEpisode.DeletedByUserID, updatedEpisode.Season, updatedEpisode.Number, updatedEpisode.AbsoluteNumber, updatedEpisode.Name, updatedEpisode.BaseDuration, updatedEpisode.ShowID, updatedEpisode.ID,
	)
	if err != nil {
		return internal.Episode{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Episode{}, err
	}
	if changedRows != 1 {
		return internal.Episode{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisode, err
}

func updateEpisode(ctx context.Context, db internal.Database, episode internal.Episode) (internal.Episode, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Episode{}, err
	}
	defer tx.Rollback()

	result, err := updateEpisodeInTx(ctx, tx, episode)
	if err != nil {
		return internal.Episode{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteEpisodeInTx(ctx context.Context, tx internal.Tx, inputEpisode internal.Episode) (internal.Episode, error) {
	// Don't delete it if it's already deleted
	if inputEpisode.DeletedAt != nil && inputEpisode.DeletedByUserID != nil {
		return inputEpisode, nil
	}

	updatedEpisode := inputEpisode
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Episode{}, err
	}
	now := time.Now()
	updatedEpisode.UpdatedAt = now
	updatedEpisode.UpdatedByUserID = claims.UserID
	updatedEpisode.DeletedAt = &now
	updatedEpisode.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE episodes SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, season=$7, number=$8, absolute_number=$9, name=$10, base_duration=$11, show_id=$12 WHERE id = $13",
		updatedEpisode.CreatedAt, updatedEpisode.CreatedByUserID, updatedEpisode.UpdatedAt, updatedEpisode.UpdatedByUserID, updatedEpisode.DeletedAt, updatedEpisode.DeletedByUserID, updatedEpisode.Season, updatedEpisode.Number, updatedEpisode.AbsoluteNumber, updatedEpisode.Name, updatedEpisode.BaseDuration, updatedEpisode.ShowID, updatedEpisode.ID,
	)
	if err != nil {
		return internal.Episode{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Episode{}, err
	}
	if changedRows != 1 {
		return internal.Episode{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedEpisode, err
}

// Preferences

func getPreferencesByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Preferences, error) {
	var preferences internal.Preferences
	err := tx.GetContext(ctx, &preferences, "SELECT * FROM preferences WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Preferences{}, errors1.NewRecordNotFound(fmt.Sprintf("Preferences.id=%s", id))
	}
	return preferences, err
}

func getPreferencesByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Preferences, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Preferences{}, err
	}
	defer tx.Rollback()

	result, err := getPreferencesByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Preferences{}, err
	}

	tx.Commit()
	return result, nil
}

func getPreferencesByUserIDInTx(ctx context.Context, tx internal.Tx, userID uuid.UUID) (internal.Preferences, error) {
	var preferences internal.Preferences
	err := tx.GetContext(ctx, &preferences, "SELECT * FROM preferences WHERE user_id=$1 AND deleted_at IS NULL", userID)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Preferences{}, errors1.NewRecordNotFound(fmt.Sprintf("Preferences.userID=%s", userID))
	}
	return preferences, err
}

func getPreferencesByUserID(ctx context.Context, db internal.Database, UserID uuid.UUID) (internal.Preferences, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Preferences{}, err
	}
	defer tx.Rollback()

	result, err := getPreferencesByUserIDInTx(ctx, tx, UserID)
	if err != nil {
		return internal.Preferences{}, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedPreferencesByUserIDInTx(ctx context.Context, tx internal.Tx, userID uuid.UUID) (internal.Preferences, error) {
	var preferences internal.Preferences
	err := tx.GetContext(ctx, &preferences, "SELECT * FROM preferences WHERE user_id=$1", userID)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Preferences{}, errors1.NewRecordNotFound(fmt.Sprintf("Preferences.userID=%s", userID))
	}
	return preferences, err
}

func getUnscopedPreferencesByUserID(ctx context.Context, db internal.Database, UserID uuid.UUID) (internal.Preferences, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Preferences{}, err
	}
	defer tx.Rollback()

	result, err := getUnscopedPreferencesByUserIDInTx(ctx, tx, UserID)
	if err != nil {
		return internal.Preferences{}, err
	}

	tx.Commit()
	return result, nil
}

func searchPreferences(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.Preferences, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, updated_at, deleted_at, user_id, enable_auto_skip, enable_auto_play, minimize_toolbar_when_editing, hide_timeline_when_minimized, color_theme, skip_branding, skip_intros, skip_new_intros, skip_mixed_intros, skip_recaps, skip_filler, skip_canon, skip_transitions, skip_credits, skip_new_credits, skip_mixed_credits, skip_preview, skip_title_card FROM preferences")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.Preferences{}
	for rows.Next() {
		var row internal.Preferences
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertPreferencesInTx(ctx context.Context, tx internal.Tx, preferences internal.Preferences) (internal.Preferences, error) {
	newPreferences := preferences
	now := time.Now()
	newPreferences.CreatedAt = now
	newPreferences.UpdatedAt = now
	newPreferences.DeletedAt = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO preferences(id, created_at, updated_at, deleted_at, user_id, enable_auto_skip, enable_auto_play, minimize_toolbar_when_editing, hide_timeline_when_minimized, color_theme, skip_branding, skip_intros, skip_new_intros, skip_mixed_intros, skip_recaps, skip_filler, skip_canon, skip_transitions, skip_credits, skip_new_credits, skip_mixed_credits, skip_preview, skip_title_card) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23)",
		newPreferences.ID, newPreferences.CreatedAt, newPreferences.UpdatedAt, newPreferences.DeletedAt, newPreferences.UserID, newPreferences.EnableAutoSkip, newPreferences.EnableAutoPlay, newPreferences.MinimizeToolbarWhenEditing, newPreferences.HideTimelineWhenMinimized, newPreferences.ColorTheme, newPreferences.SkipBranding, newPreferences.SkipIntros, newPreferences.SkipNewIntros, newPreferences.SkipMixedIntros, newPreferences.SkipRecaps, newPreferences.SkipFiller, newPreferences.SkipCanon, newPreferences.SkipTransitions, newPreferences.SkipCredits, newPreferences.SkipNewCredits, newPreferences.SkipMixedCredits, newPreferences.SkipPreview, newPreferences.SkipTitleCard,
	)
	if err != nil {
		return internal.Preferences{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Preferences{}, err
	}
	if changedRows != 1 {
		return internal.Preferences{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newPreferences, err
}

func insertPreferences(ctx context.Context, db internal.Database, preferences internal.Preferences) (internal.Preferences, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Preferences{}, err
	}
	defer tx.Rollback()

	result, err := insertPreferencesInTx(ctx, tx, preferences)
	if err != nil {
		return internal.Preferences{}, err
	}

	tx.Commit()
	return result, nil
}

func updatePreferencesInTx(ctx context.Context, tx internal.Tx, inputPreferences internal.Preferences) (internal.Preferences, error) {
	updatedPreferences := inputPreferences
	now := time.Now()
	updatedPreferences.UpdatedAt = now
	result, err := tx.ExecContext(
		ctx,
		"UPDATE preferences SET created_at=$1, updated_at=$2, deleted_at=$3, user_id=$4, enable_auto_skip=$5, enable_auto_play=$6, minimize_toolbar_when_editing=$7, hide_timeline_when_minimized=$8, color_theme=$9, skip_branding=$10, skip_intros=$11, skip_new_intros=$12, skip_mixed_intros=$13, skip_recaps=$14, skip_filler=$15, skip_canon=$16, skip_transitions=$17, skip_credits=$18, skip_new_credits=$19, skip_mixed_credits=$20, skip_preview=$21, skip_title_card=$22 WHERE id = $23",
		updatedPreferences.CreatedAt, updatedPreferences.UpdatedAt, updatedPreferences.DeletedAt, updatedPreferences.UserID, updatedPreferences.EnableAutoSkip, updatedPreferences.EnableAutoPlay, updatedPreferences.MinimizeToolbarWhenEditing, updatedPreferences.HideTimelineWhenMinimized, updatedPreferences.ColorTheme, updatedPreferences.SkipBranding, updatedPreferences.SkipIntros, updatedPreferences.SkipNewIntros, updatedPreferences.SkipMixedIntros, updatedPreferences.SkipRecaps, updatedPreferences.SkipFiller, updatedPreferences.SkipCanon, updatedPreferences.SkipTransitions, updatedPreferences.SkipCredits, updatedPreferences.SkipNewCredits, updatedPreferences.SkipMixedCredits, updatedPreferences.SkipPreview, updatedPreferences.SkipTitleCard, updatedPreferences.ID,
	)
	if err != nil {
		return internal.Preferences{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Preferences{}, err
	}
	if changedRows != 1 {
		return internal.Preferences{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedPreferences, err
}

func updatePreferences(ctx context.Context, db internal.Database, preferences internal.Preferences) (internal.Preferences, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Preferences{}, err
	}
	defer tx.Rollback()

	result, err := updatePreferencesInTx(ctx, tx, preferences)
	if err != nil {
		return internal.Preferences{}, err
	}

	tx.Commit()
	return result, nil
}

func deletePreferencesInTx(ctx context.Context, tx internal.Tx, inputPreferences internal.Preferences) (internal.Preferences, error) {
	// Don't delete it if it's already deleted
	if inputPreferences.DeletedAt != nil {
		return inputPreferences, nil
	}

	updatedPreferences := inputPreferences
	now := time.Now()
	updatedPreferences.UpdatedAt = now
	updatedPreferences.DeletedAt = &now
	result, err := tx.ExecContext(
		ctx,
		"UPDATE preferences SET created_at=$1, updated_at=$2, deleted_at=$3, user_id=$4, enable_auto_skip=$5, enable_auto_play=$6, minimize_toolbar_when_editing=$7, hide_timeline_when_minimized=$8, color_theme=$9, skip_branding=$10, skip_intros=$11, skip_new_intros=$12, skip_mixed_intros=$13, skip_recaps=$14, skip_filler=$15, skip_canon=$16, skip_transitions=$17, skip_credits=$18, skip_new_credits=$19, skip_mixed_credits=$20, skip_preview=$21, skip_title_card=$22 WHERE id = $23",
		updatedPreferences.CreatedAt, updatedPreferences.UpdatedAt, updatedPreferences.DeletedAt, updatedPreferences.UserID, updatedPreferences.EnableAutoSkip, updatedPreferences.EnableAutoPlay, updatedPreferences.MinimizeToolbarWhenEditing, updatedPreferences.HideTimelineWhenMinimized, updatedPreferences.ColorTheme, updatedPreferences.SkipBranding, updatedPreferences.SkipIntros, updatedPreferences.SkipNewIntros, updatedPreferences.SkipMixedIntros, updatedPreferences.SkipRecaps, updatedPreferences.SkipFiller, updatedPreferences.SkipCanon, updatedPreferences.SkipTransitions, updatedPreferences.SkipCredits, updatedPreferences.SkipNewCredits, updatedPreferences.SkipMixedCredits, updatedPreferences.SkipPreview, updatedPreferences.SkipTitleCard, updatedPreferences.ID,
	)
	if err != nil {
		return internal.Preferences{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Preferences{}, err
	}
	if changedRows != 1 {
		return internal.Preferences{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedPreferences, err
}

// ShowAdmin

func getShowAdminByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.ShowAdmin, error) {
	var showAdmin internal.ShowAdmin
	err := tx.GetContext(ctx, &showAdmin, "SELECT * FROM show_admins WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.ShowAdmin{}, errors1.NewRecordNotFound(fmt.Sprintf("ShowAdmin.id=%s", id))
	}
	return showAdmin, err
}

func getShowAdminByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	defer tx.Rollback()

	result, err := getShowAdminByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.ShowAdmin{}, err
	}

	tx.Commit()
	return result, nil
}

func getShowAdminsByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.ShowAdmin, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM show_admins WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	showAdmins := []internal.ShowAdmin{}
	for rows.Next() {
		var showAdmin internal.ShowAdmin
		err = rows.StructScan(&showAdmin)
		if err != nil {
			return nil, err
		}
		showAdmins = append(showAdmins, showAdmin)
	}
	return showAdmins, nil
}

func getShowAdminsByShowID(ctx context.Context, db internal.Database, showID uuid.UUID) ([]internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getShowAdminsByShowIDInTx(ctx, tx, showID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedShowAdminsByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.ShowAdmin, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM show_admins")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	showAdmins := []internal.ShowAdmin{}
	for rows.Next() {
		var showAdmin internal.ShowAdmin
		err = rows.StructScan(&showAdmin)
		if err != nil {
			return nil, err
		}
		showAdmins = append(showAdmins, showAdmin)
	}
	return showAdmins, nil
}

func getUnscopedShowAdminsByShowID(ctx context.Context, db internal.Database, showID uuid.UUID) ([]internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedShowAdminsByShowIDInTx(ctx, tx, showID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getShowAdminsByUserIDInTx(ctx context.Context, tx internal.Tx, userID uuid.UUID) ([]internal.ShowAdmin, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM show_admins WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	showAdmins := []internal.ShowAdmin{}
	for rows.Next() {
		var showAdmin internal.ShowAdmin
		err = rows.StructScan(&showAdmin)
		if err != nil {
			return nil, err
		}
		showAdmins = append(showAdmins, showAdmin)
	}
	return showAdmins, nil
}

func getShowAdminsByUserID(ctx context.Context, db internal.Database, userID uuid.UUID) ([]internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getShowAdminsByUserIDInTx(ctx, tx, userID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedShowAdminsByUserIDInTx(ctx context.Context, tx internal.Tx, userID uuid.UUID) ([]internal.ShowAdmin, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM show_admins")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	showAdmins := []internal.ShowAdmin{}
	for rows.Next() {
		var showAdmin internal.ShowAdmin
		err = rows.StructScan(&showAdmin)
		if err != nil {
			return nil, err
		}
		showAdmins = append(showAdmins, showAdmin)
	}
	return showAdmins, nil
}

func getUnscopedShowAdminsByUserID(ctx context.Context, db internal.Database, userID uuid.UUID) ([]internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedShowAdminsByUserIDInTx(ctx, tx, userID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchShowAdmins(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.ShowAdmin, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, show_id, user_id FROM show_admins")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.ShowAdmin{}
	for rows.Next() {
		var row internal.ShowAdmin
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertShowAdminInTx(ctx context.Context, tx internal.Tx, showAdmin internal.ShowAdmin) (internal.ShowAdmin, error) {
	newShowAdmin := showAdmin
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	now := time.Now()
	newShowAdmin.CreatedAt = now
	newShowAdmin.CreatedByUserID = claims.UserID
	newShowAdmin.UpdatedAt = now
	newShowAdmin.UpdatedByUserID = claims.UserID
	newShowAdmin.DeletedAt = nil
	newShowAdmin.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO show_admins(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, show_id, user_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newShowAdmin.ID, newShowAdmin.CreatedAt, newShowAdmin.CreatedByUserID, newShowAdmin.UpdatedAt, newShowAdmin.UpdatedByUserID, newShowAdmin.DeletedAt, newShowAdmin.DeletedByUserID, newShowAdmin.ShowID, newShowAdmin.UserID,
	)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	if changedRows != 1 {
		return internal.ShowAdmin{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newShowAdmin, err
}

func insertShowAdmin(ctx context.Context, db internal.Database, showAdmin internal.ShowAdmin) (internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	defer tx.Rollback()

	result, err := insertShowAdminInTx(ctx, tx, showAdmin)
	if err != nil {
		return internal.ShowAdmin{}, err
	}

	tx.Commit()
	return result, nil
}

func updateShowAdminInTx(ctx context.Context, tx internal.Tx, inputShowAdmin internal.ShowAdmin) (internal.ShowAdmin, error) {
	updatedShowAdmin := inputShowAdmin
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	now := time.Now()
	updatedShowAdmin.UpdatedAt = now
	updatedShowAdmin.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE show_admins SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, show_id=$7, user_id=$8 WHERE id = $9",
		updatedShowAdmin.CreatedAt, updatedShowAdmin.CreatedByUserID, updatedShowAdmin.UpdatedAt, updatedShowAdmin.UpdatedByUserID, updatedShowAdmin.DeletedAt, updatedShowAdmin.DeletedByUserID, updatedShowAdmin.ShowID, updatedShowAdmin.UserID, updatedShowAdmin.ID,
	)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	if changedRows != 1 {
		return internal.ShowAdmin{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedShowAdmin, err
}

func updateShowAdmin(ctx context.Context, db internal.Database, showAdmin internal.ShowAdmin) (internal.ShowAdmin, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	defer tx.Rollback()

	result, err := updateShowAdminInTx(ctx, tx, showAdmin)
	if err != nil {
		return internal.ShowAdmin{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteShowAdminInTx(ctx context.Context, tx internal.Tx, inputShowAdmin internal.ShowAdmin) (internal.ShowAdmin, error) {
	// Don't delete it if it's already deleted
	if inputShowAdmin.DeletedAt != nil && inputShowAdmin.DeletedByUserID != nil {
		return inputShowAdmin, nil
	}

	updatedShowAdmin := inputShowAdmin
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	now := time.Now()
	updatedShowAdmin.UpdatedAt = now
	updatedShowAdmin.UpdatedByUserID = claims.UserID
	updatedShowAdmin.DeletedAt = &now
	updatedShowAdmin.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE show_admins SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, show_id=$7, user_id=$8 WHERE id = $9",
		updatedShowAdmin.CreatedAt, updatedShowAdmin.CreatedByUserID, updatedShowAdmin.UpdatedAt, updatedShowAdmin.UpdatedByUserID, updatedShowAdmin.DeletedAt, updatedShowAdmin.DeletedByUserID, updatedShowAdmin.ShowID, updatedShowAdmin.UserID, updatedShowAdmin.ID,
	)
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.ShowAdmin{}, err
	}
	if changedRows != 1 {
		return internal.ShowAdmin{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedShowAdmin, err
}

// Show

func getShowByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Show, error) {
	var show internal.Show
	err := tx.GetContext(ctx, &show, "SELECT * FROM shows WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Show{}, errors1.NewRecordNotFound(fmt.Sprintf("Show.id=%s", id))
	}
	return show, err
}

func getShowByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Show, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Show{}, err
	}
	defer tx.Rollback()

	result, err := getShowByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Show{}, err
	}

	tx.Commit()
	return result, nil
}

func searchShows(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.Show, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, name, original_name, website, image FROM shows")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.Show{}
	for rows.Next() {
		var row internal.Show
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertShowInTx(ctx context.Context, tx internal.Tx, show internal.Show) (internal.Show, error) {
	newShow := show
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Show{}, err
	}
	now := time.Now()
	newShow.CreatedAt = now
	newShow.CreatedByUserID = claims.UserID
	newShow.UpdatedAt = now
	newShow.UpdatedByUserID = claims.UserID
	newShow.DeletedAt = nil
	newShow.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO shows(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, name, original_name, website, image) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)",
		newShow.ID, newShow.CreatedAt, newShow.CreatedByUserID, newShow.UpdatedAt, newShow.UpdatedByUserID, newShow.DeletedAt, newShow.DeletedByUserID, newShow.Name, newShow.OriginalName, newShow.Website, newShow.Image,
	)
	if err != nil {
		return internal.Show{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Show{}, err
	}
	if changedRows != 1 {
		return internal.Show{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newShow, err
}

func insertShow(ctx context.Context, db internal.Database, show internal.Show) (internal.Show, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Show{}, err
	}
	defer tx.Rollback()

	result, err := insertShowInTx(ctx, tx, show)
	if err != nil {
		return internal.Show{}, err
	}

	tx.Commit()
	return result, nil
}

func updateShowInTx(ctx context.Context, tx internal.Tx, inputShow internal.Show) (internal.Show, error) {
	updatedShow := inputShow
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Show{}, err
	}
	now := time.Now()
	updatedShow.UpdatedAt = now
	updatedShow.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE shows SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, name=$7, original_name=$8, website=$9, image=$10 WHERE id = $11",
		updatedShow.CreatedAt, updatedShow.CreatedByUserID, updatedShow.UpdatedAt, updatedShow.UpdatedByUserID, updatedShow.DeletedAt, updatedShow.DeletedByUserID, updatedShow.Name, updatedShow.OriginalName, updatedShow.Website, updatedShow.Image, updatedShow.ID,
	)
	if err != nil {
		return internal.Show{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Show{}, err
	}
	if changedRows != 1 {
		return internal.Show{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedShow, err
}

func updateShow(ctx context.Context, db internal.Database, show internal.Show) (internal.Show, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Show{}, err
	}
	defer tx.Rollback()

	result, err := updateShowInTx(ctx, tx, show)
	if err != nil {
		return internal.Show{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteShowInTx(ctx context.Context, tx internal.Tx, inputShow internal.Show) (internal.Show, error) {
	// Don't delete it if it's already deleted
	if inputShow.DeletedAt != nil && inputShow.DeletedByUserID != nil {
		return inputShow, nil
	}

	updatedShow := inputShow
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Show{}, err
	}
	now := time.Now()
	updatedShow.UpdatedAt = now
	updatedShow.UpdatedByUserID = claims.UserID
	updatedShow.DeletedAt = &now
	updatedShow.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE shows SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, name=$7, original_name=$8, website=$9, image=$10 WHERE id = $11",
		updatedShow.CreatedAt, updatedShow.CreatedByUserID, updatedShow.UpdatedAt, updatedShow.UpdatedByUserID, updatedShow.DeletedAt, updatedShow.DeletedByUserID, updatedShow.Name, updatedShow.OriginalName, updatedShow.Website, updatedShow.Image, updatedShow.ID,
	)
	if err != nil {
		return internal.Show{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Show{}, err
	}
	if changedRows != 1 {
		return internal.Show{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedShow, err
}

// TemplateTimestamp

func getTemplateTimestampInTx(ctx context.Context, tx internal.Tx, templateID uuid.UUID, timestampID uuid.UUID) (internal.TemplateTimestamp, error) {
	var templateTimestamp internal.TemplateTimestamp
	err := tx.GetContext(ctx, &templateTimestamp, "SELECT * FROM template_timestamps WHERE template_id=$1 AND timestamp_id=$2", templateID, timestampID)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.TemplateTimestamp{}, errors1.NewRecordNotFound(fmt.Sprintf("TemplateTimestamp.templateID=%s and TemplateTimestamp.timestampID=%s", templateID, timestampID))
	}
	return templateTimestamp, err
}

func getTemplateTimestampByTimestampIDInTx(ctx context.Context, tx internal.Tx, timestampID uuid.UUID) (internal.TemplateTimestamp, error) {
	var templateTimestamp internal.TemplateTimestamp
	err := tx.GetContext(ctx, &templateTimestamp, "SELECT * FROM template_timestamps WHERE timestamp_id=$1", timestampID)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.TemplateTimestamp{}, errors1.NewRecordNotFound(fmt.Sprintf("TemplateTimestamp.timestampID=%s", timestampID))
	}
	return templateTimestamp, err
}

func getTemplateTimestampByTimestampID(ctx context.Context, db internal.Database, TimestampID uuid.UUID) (internal.TemplateTimestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TemplateTimestamp{}, err
	}
	defer tx.Rollback()

	result, err := getTemplateTimestampByTimestampIDInTx(ctx, tx, TimestampID)
	if err != nil {
		return internal.TemplateTimestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func getTemplateTimestampsByTemplateIDInTx(ctx context.Context, tx internal.Tx, templateID uuid.UUID) ([]internal.TemplateTimestamp, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM template_timestamps")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	templateTimestamps := []internal.TemplateTimestamp{}
	for rows.Next() {
		var templateTimestamp internal.TemplateTimestamp
		err = rows.StructScan(&templateTimestamp)
		if err != nil {
			return nil, err
		}
		templateTimestamps = append(templateTimestamps, templateTimestamp)
	}
	return templateTimestamps, nil
}

func getTemplateTimestampsByTemplateID(ctx context.Context, db internal.Database, templateID uuid.UUID) ([]internal.TemplateTimestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getTemplateTimestampsByTemplateIDInTx(ctx, tx, templateID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchTemplateTimestamps(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.TemplateTimestamp, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT template_id, timestamp_id FROM template_timestamps")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.TemplateTimestamp{}
	for rows.Next() {
		var row internal.TemplateTimestamp
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertTemplateTimestampInTx(ctx context.Context, tx internal.Tx, templateTimestamp internal.TemplateTimestamp) (internal.TemplateTimestamp, error) {
	newTemplateTimestamp := templateTimestamp
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO template_timestamps(template_id, timestamp_id) VALUES ($1, $2)",
		newTemplateTimestamp.TemplateID, newTemplateTimestamp.TimestampID,
	)
	if err != nil {
		return internal.TemplateTimestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TemplateTimestamp{}, err
	}
	if changedRows != 1 {
		return internal.TemplateTimestamp{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newTemplateTimestamp, err
}

func insertTemplateTimestamp(ctx context.Context, db internal.Database, templateTimestamp internal.TemplateTimestamp) (internal.TemplateTimestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TemplateTimestamp{}, err
	}
	defer tx.Rollback()

	result, err := insertTemplateTimestampInTx(ctx, tx, templateTimestamp)
	if err != nil {
		return internal.TemplateTimestamp{}, err
	}

	tx.Commit()
	return result, nil
}

// Hard delete the TemplateTimestamp. It requires the entire model be passed in so that you have it before calling this function, and can return the value if needed
func deleteTemplateTimestampInTx(ctx context.Context, tx internal.Tx, templateTimestamp internal.TemplateTimestamp) error {
	result, err := tx.ExecContext(ctx, "DELETE FROM template_timestamps WHERE template_id=$1 AND timestamp_id=$2", templateTimestamp.TemplateID, templateTimestamp.TimestampID)
	if err != nil {
		return err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if changedRows != 1 {
		return fmt.Errorf("Deleted more than 1 row (%d)", changedRows)
	}
	return err
}

// Template

func getTemplateByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Template, error) {
	var template internal.Template
	err := tx.GetContext(ctx, &template, "SELECT * FROM templates WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Template{}, errors1.NewRecordNotFound(fmt.Sprintf("Template.id=%s", id))
	}
	return template, err
}

func getTemplateByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Template{}, err
	}
	defer tx.Rollback()

	result, err := getTemplateByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Template{}, err
	}

	tx.Commit()
	return result, nil
}

func getTemplateBySourceEpisodeIDInTx(ctx context.Context, tx internal.Tx, sourceEpisodeID uuid.UUID) (internal.Template, error) {
	var template internal.Template
	err := tx.GetContext(ctx, &template, "SELECT * FROM templates WHERE source_episode_id=$1 AND deleted_at IS NULL", sourceEpisodeID)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Template{}, errors1.NewRecordNotFound(fmt.Sprintf("Template.sourceEpisodeID=%s", sourceEpisodeID))
	}
	return template, err
}

func getTemplateBySourceEpisodeID(ctx context.Context, db internal.Database, SourceEpisodeID uuid.UUID) (internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Template{}, err
	}
	defer tx.Rollback()

	result, err := getTemplateBySourceEpisodeIDInTx(ctx, tx, SourceEpisodeID)
	if err != nil {
		return internal.Template{}, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedTemplateBySourceEpisodeIDInTx(ctx context.Context, tx internal.Tx, sourceEpisodeID uuid.UUID) (internal.Template, error) {
	var template internal.Template
	err := tx.GetContext(ctx, &template, "SELECT * FROM templates WHERE source_episode_id=$1", sourceEpisodeID)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Template{}, errors1.NewRecordNotFound(fmt.Sprintf("Template.sourceEpisodeID=%s", sourceEpisodeID))
	}
	return template, err
}

func getUnscopedTemplateBySourceEpisodeID(ctx context.Context, db internal.Database, SourceEpisodeID uuid.UUID) (internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Template{}, err
	}
	defer tx.Rollback()

	result, err := getUnscopedTemplateBySourceEpisodeIDInTx(ctx, tx, SourceEpisodeID)
	if err != nil {
		return internal.Template{}, err
	}

	tx.Commit()
	return result, nil
}

func getTemplatesByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.Template, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM templates WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	templates := []internal.Template{}
	for rows.Next() {
		var template internal.Template
		err = rows.StructScan(&template)
		if err != nil {
			return nil, err
		}
		templates = append(templates, template)
	}
	return templates, nil
}

func getTemplatesByShowID(ctx context.Context, db internal.Database, showID uuid.UUID) ([]internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getTemplatesByShowIDInTx(ctx, tx, showID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedTemplatesByShowIDInTx(ctx context.Context, tx internal.Tx, showID uuid.UUID) ([]internal.Template, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM templates")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	templates := []internal.Template{}
	for rows.Next() {
		var template internal.Template
		err = rows.StructScan(&template)
		if err != nil {
			return nil, err
		}
		templates = append(templates, template)
	}
	return templates, nil
}

func getUnscopedTemplatesByShowID(ctx context.Context, db internal.Database, showID uuid.UUID) ([]internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedTemplatesByShowIDInTx(ctx, tx, showID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchTemplates(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.Template, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, show_id, type, seasons, source_episode_id FROM templates")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.Template{}
	for rows.Next() {
		var row internal.Template
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertTemplateInTx(ctx context.Context, tx internal.Tx, template internal.Template) (internal.Template, error) {
	newTemplate := template
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Template{}, err
	}
	now := time.Now()
	newTemplate.CreatedAt = now
	newTemplate.CreatedByUserID = claims.UserID
	newTemplate.UpdatedAt = now
	newTemplate.UpdatedByUserID = claims.UserID
	newTemplate.DeletedAt = nil
	newTemplate.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO templates(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, show_id, type, seasons, source_episode_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)",
		newTemplate.ID, newTemplate.CreatedAt, newTemplate.CreatedByUserID, newTemplate.UpdatedAt, newTemplate.UpdatedByUserID, newTemplate.DeletedAt, newTemplate.DeletedByUserID, newTemplate.ShowID, newTemplate.Type, newTemplate.Seasons, newTemplate.SourceEpisodeID,
	)
	if err != nil {
		return internal.Template{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Template{}, err
	}
	if changedRows != 1 {
		return internal.Template{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newTemplate, err
}

func insertTemplate(ctx context.Context, db internal.Database, template internal.Template) (internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Template{}, err
	}
	defer tx.Rollback()

	result, err := insertTemplateInTx(ctx, tx, template)
	if err != nil {
		return internal.Template{}, err
	}

	tx.Commit()
	return result, nil
}

func updateTemplateInTx(ctx context.Context, tx internal.Tx, inputTemplate internal.Template) (internal.Template, error) {
	updatedTemplate := inputTemplate
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Template{}, err
	}
	now := time.Now()
	updatedTemplate.UpdatedAt = now
	updatedTemplate.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE templates SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, show_id=$7, type=$8, seasons=$9, source_episode_id=$10 WHERE id = $11",
		updatedTemplate.CreatedAt, updatedTemplate.CreatedByUserID, updatedTemplate.UpdatedAt, updatedTemplate.UpdatedByUserID, updatedTemplate.DeletedAt, updatedTemplate.DeletedByUserID, updatedTemplate.ShowID, updatedTemplate.Type, updatedTemplate.Seasons, updatedTemplate.SourceEpisodeID, updatedTemplate.ID,
	)
	if err != nil {
		return internal.Template{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Template{}, err
	}
	if changedRows != 1 {
		return internal.Template{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTemplate, err
}

func updateTemplate(ctx context.Context, db internal.Database, template internal.Template) (internal.Template, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Template{}, err
	}
	defer tx.Rollback()

	result, err := updateTemplateInTx(ctx, tx, template)
	if err != nil {
		return internal.Template{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteTemplateInTx(ctx context.Context, tx internal.Tx, inputTemplate internal.Template) (internal.Template, error) {
	// Don't delete it if it's already deleted
	if inputTemplate.DeletedAt != nil && inputTemplate.DeletedByUserID != nil {
		return inputTemplate, nil
	}

	updatedTemplate := inputTemplate
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Template{}, err
	}
	now := time.Now()
	updatedTemplate.UpdatedAt = now
	updatedTemplate.UpdatedByUserID = claims.UserID
	updatedTemplate.DeletedAt = &now
	updatedTemplate.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE templates SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, show_id=$7, type=$8, seasons=$9, source_episode_id=$10 WHERE id = $11",
		updatedTemplate.CreatedAt, updatedTemplate.CreatedByUserID, updatedTemplate.UpdatedAt, updatedTemplate.UpdatedByUserID, updatedTemplate.DeletedAt, updatedTemplate.DeletedByUserID, updatedTemplate.ShowID, updatedTemplate.Type, updatedTemplate.Seasons, updatedTemplate.SourceEpisodeID, updatedTemplate.ID,
	)
	if err != nil {
		return internal.Template{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Template{}, err
	}
	if changedRows != 1 {
		return internal.Template{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTemplate, err
}

// TimestampType

func getTimestampTypeByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.TimestampType, error) {
	var timestampType internal.TimestampType
	err := tx.GetContext(ctx, &timestampType, "SELECT * FROM timestamp_types WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.TimestampType{}, errors1.NewRecordNotFound(fmt.Sprintf("TimestampType.id=%s", id))
	}
	return timestampType, err
}

func getTimestampTypeByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.TimestampType, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TimestampType{}, err
	}
	defer tx.Rollback()

	result, err := getTimestampTypeByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.TimestampType{}, err
	}

	tx.Commit()
	return result, nil
}

func searchTimestampTypes(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.TimestampType, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, name, description FROM timestamp_types")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.TimestampType{}
	for rows.Next() {
		var row internal.TimestampType
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertTimestampTypeInTx(ctx context.Context, tx internal.Tx, timestampType internal.TimestampType) (internal.TimestampType, error) {
	newTimestampType := timestampType
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.TimestampType{}, err
	}
	now := time.Now()
	newTimestampType.CreatedAt = now
	newTimestampType.CreatedByUserID = claims.UserID
	newTimestampType.UpdatedAt = now
	newTimestampType.UpdatedByUserID = claims.UserID
	newTimestampType.DeletedAt = nil
	newTimestampType.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO timestamp_types(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, name, description) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newTimestampType.ID, newTimestampType.CreatedAt, newTimestampType.CreatedByUserID, newTimestampType.UpdatedAt, newTimestampType.UpdatedByUserID, newTimestampType.DeletedAt, newTimestampType.DeletedByUserID, newTimestampType.Name, newTimestampType.Description,
	)
	if err != nil {
		return internal.TimestampType{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TimestampType{}, err
	}
	if changedRows != 1 {
		return internal.TimestampType{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newTimestampType, err
}

func insertTimestampType(ctx context.Context, db internal.Database, timestampType internal.TimestampType) (internal.TimestampType, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TimestampType{}, err
	}
	defer tx.Rollback()

	result, err := insertTimestampTypeInTx(ctx, tx, timestampType)
	if err != nil {
		return internal.TimestampType{}, err
	}

	tx.Commit()
	return result, nil
}

func updateTimestampTypeInTx(ctx context.Context, tx internal.Tx, inputTimestampType internal.TimestampType) (internal.TimestampType, error) {
	updatedTimestampType := inputTimestampType
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.TimestampType{}, err
	}
	now := time.Now()
	updatedTimestampType.UpdatedAt = now
	updatedTimestampType.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamp_types SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, name=$7, description=$8 WHERE id = $9",
		updatedTimestampType.CreatedAt, updatedTimestampType.CreatedByUserID, updatedTimestampType.UpdatedAt, updatedTimestampType.UpdatedByUserID, updatedTimestampType.DeletedAt, updatedTimestampType.DeletedByUserID, updatedTimestampType.Name, updatedTimestampType.Description, updatedTimestampType.ID,
	)
	if err != nil {
		return internal.TimestampType{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TimestampType{}, err
	}
	if changedRows != 1 {
		return internal.TimestampType{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestampType, err
}

func updateTimestampType(ctx context.Context, db internal.Database, timestampType internal.TimestampType) (internal.TimestampType, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.TimestampType{}, err
	}
	defer tx.Rollback()

	result, err := updateTimestampTypeInTx(ctx, tx, timestampType)
	if err != nil {
		return internal.TimestampType{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteTimestampTypeInTx(ctx context.Context, tx internal.Tx, inputTimestampType internal.TimestampType) (internal.TimestampType, error) {
	// Don't delete it if it's already deleted
	if inputTimestampType.DeletedAt != nil && inputTimestampType.DeletedByUserID != nil {
		return inputTimestampType, nil
	}

	updatedTimestampType := inputTimestampType
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.TimestampType{}, err
	}
	now := time.Now()
	updatedTimestampType.UpdatedAt = now
	updatedTimestampType.UpdatedByUserID = claims.UserID
	updatedTimestampType.DeletedAt = &now
	updatedTimestampType.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamp_types SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, name=$7, description=$8 WHERE id = $9",
		updatedTimestampType.CreatedAt, updatedTimestampType.CreatedByUserID, updatedTimestampType.UpdatedAt, updatedTimestampType.UpdatedByUserID, updatedTimestampType.DeletedAt, updatedTimestampType.DeletedByUserID, updatedTimestampType.Name, updatedTimestampType.Description, updatedTimestampType.ID,
	)
	if err != nil {
		return internal.TimestampType{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.TimestampType{}, err
	}
	if changedRows != 1 {
		return internal.TimestampType{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestampType, err
}

// Timestamp

func getTimestampByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.Timestamp, error) {
	var timestamp internal.Timestamp
	err := tx.GetContext(ctx, &timestamp, "SELECT * FROM timestamps WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.Timestamp{}, errors1.NewRecordNotFound(fmt.Sprintf("Timestamp.id=%s", id))
	}
	return timestamp, err
}

func getTimestampByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Timestamp{}, err
	}
	defer tx.Rollback()

	result, err := getTimestampByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.Timestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func getTimestampsByEpisodeIDInTx(ctx context.Context, tx internal.Tx, episodeID uuid.UUID) ([]internal.Timestamp, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM timestamps WHERE deleted_at IS NULL")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	timestamps := []internal.Timestamp{}
	for rows.Next() {
		var timestamp internal.Timestamp
		err = rows.StructScan(&timestamp)
		if err != nil {
			return nil, err
		}
		timestamps = append(timestamps, timestamp)
	}
	return timestamps, nil
}

func getTimestampsByEpisodeID(ctx context.Context, db internal.Database, episodeID uuid.UUID) ([]internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getTimestampsByEpisodeIDInTx(ctx, tx, episodeID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedTimestampsByEpisodeIDInTx(ctx context.Context, tx internal.Tx, episodeID uuid.UUID) ([]internal.Timestamp, error) {
	rows, err := tx.QueryxContext(ctx, "SELECT * FROM timestamps")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	timestamps := []internal.Timestamp{}
	for rows.Next() {
		var timestamp internal.Timestamp
		err = rows.StructScan(&timestamp)
		if err != nil {
			return nil, err
		}
		timestamps = append(timestamps, timestamp)
	}
	return timestamps, nil
}

func getUnscopedTimestampsByEpisodeID(ctx context.Context, db internal.Database, episodeID uuid.UUID) ([]internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	result, err := getUnscopedTimestampsByEpisodeIDInTx(ctx, tx, episodeID)
	if err != nil {
		return nil, err
	}

	tx.Commit()
	return result, nil
}

func searchTimestamps(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.Timestamp, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, at, source, type_id, episode_id FROM timestamps")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.Timestamp{}
	for rows.Next() {
		var row internal.Timestamp
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertTimestampInTx(ctx context.Context, tx internal.Tx, timestamp internal.Timestamp) (internal.Timestamp, error) {
	newTimestamp := timestamp
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Timestamp{}, err
	}
	now := time.Now()
	newTimestamp.CreatedAt = now
	newTimestamp.CreatedByUserID = claims.UserID
	newTimestamp.UpdatedAt = now
	newTimestamp.UpdatedByUserID = claims.UserID
	newTimestamp.DeletedAt = nil
	newTimestamp.DeletedByUserID = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO timestamps(id, created_at, created_by_user_id, updated_at, updated_by_user_id, deleted_at, deleted_by_user_id, at, source, type_id, episode_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)",
		newTimestamp.ID, newTimestamp.CreatedAt, newTimestamp.CreatedByUserID, newTimestamp.UpdatedAt, newTimestamp.UpdatedByUserID, newTimestamp.DeletedAt, newTimestamp.DeletedByUserID, newTimestamp.At, newTimestamp.Source, newTimestamp.TypeID, newTimestamp.EpisodeID,
	)
	if err != nil {
		return internal.Timestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Timestamp{}, err
	}
	if changedRows != 1 {
		return internal.Timestamp{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newTimestamp, err
}

func insertTimestamp(ctx context.Context, db internal.Database, timestamp internal.Timestamp) (internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Timestamp{}, err
	}
	defer tx.Rollback()

	result, err := insertTimestampInTx(ctx, tx, timestamp)
	if err != nil {
		return internal.Timestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func updateTimestampInTx(ctx context.Context, tx internal.Tx, inputTimestamp internal.Timestamp) (internal.Timestamp, error) {
	updatedTimestamp := inputTimestamp
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Timestamp{}, err
	}
	now := time.Now()
	updatedTimestamp.UpdatedAt = now
	updatedTimestamp.UpdatedByUserID = claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamps SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, at=$7, source=$8, type_id=$9, episode_id=$10 WHERE id = $11",
		updatedTimestamp.CreatedAt, updatedTimestamp.CreatedByUserID, updatedTimestamp.UpdatedAt, updatedTimestamp.UpdatedByUserID, updatedTimestamp.DeletedAt, updatedTimestamp.DeletedByUserID, updatedTimestamp.At, updatedTimestamp.Source, updatedTimestamp.TypeID, updatedTimestamp.EpisodeID, updatedTimestamp.ID,
	)
	if err != nil {
		return internal.Timestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Timestamp{}, err
	}
	if changedRows != 1 {
		return internal.Timestamp{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestamp, err
}

func updateTimestamp(ctx context.Context, db internal.Database, timestamp internal.Timestamp) (internal.Timestamp, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.Timestamp{}, err
	}
	defer tx.Rollback()

	result, err := updateTimestampInTx(ctx, tx, timestamp)
	if err != nil {
		return internal.Timestamp{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteTimestampInTx(ctx context.Context, tx internal.Tx, inputTimestamp internal.Timestamp) (internal.Timestamp, error) {
	// Don't delete it if it's already deleted
	if inputTimestamp.DeletedAt != nil && inputTimestamp.DeletedByUserID != nil {
		return inputTimestamp, nil
	}

	updatedTimestamp := inputTimestamp
	claims, err := context1.GetAuthClaims(ctx)
	if err != nil {
		return internal.Timestamp{}, err
	}
	now := time.Now()
	updatedTimestamp.UpdatedAt = now
	updatedTimestamp.UpdatedByUserID = claims.UserID
	updatedTimestamp.DeletedAt = &now
	updatedTimestamp.DeletedByUserID = &claims.UserID
	result, err := tx.ExecContext(
		ctx,
		"UPDATE timestamps SET created_at=$1, created_by_user_id=$2, updated_at=$3, updated_by_user_id=$4, deleted_at=$5, deleted_by_user_id=$6, at=$7, source=$8, type_id=$9, episode_id=$10 WHERE id = $11",
		updatedTimestamp.CreatedAt, updatedTimestamp.CreatedByUserID, updatedTimestamp.UpdatedAt, updatedTimestamp.UpdatedByUserID, updatedTimestamp.DeletedAt, updatedTimestamp.DeletedByUserID, updatedTimestamp.At, updatedTimestamp.Source, updatedTimestamp.TypeID, updatedTimestamp.EpisodeID, updatedTimestamp.ID,
	)
	if err != nil {
		return internal.Timestamp{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.Timestamp{}, err
	}
	if changedRows != 1 {
		return internal.Timestamp{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedTimestamp, err
}

// User

func getUserByIDInTx(ctx context.Context, tx internal.Tx, id uuid.UUID) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE id=$1", id)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.id=%s", id))
	}
	return user, err
}

func getUserByID(ctx context.Context, db internal.Database, ID uuid.UUID) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUserByIDInTx(ctx, tx, ID)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUserByUsernameInTx(ctx context.Context, tx internal.Tx, username string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE username=$1 AND deleted_at IS NULL", username)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.username=%s", username))
	}
	return user, err
}

func getUserByUsername(ctx context.Context, db internal.Database, Username string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUserByUsernameInTx(ctx, tx, Username)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedUserByUsernameInTx(ctx context.Context, tx internal.Tx, username string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE username=$1", username)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.username=%s", username))
	}
	return user, err
}

func getUnscopedUserByUsername(ctx context.Context, db internal.Database, Username string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUnscopedUserByUsernameInTx(ctx, tx, Username)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUserByEmailInTx(ctx context.Context, tx internal.Tx, email string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE email=$1 AND deleted_at IS NULL", email)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.email=%s", email))
	}
	return user, err
}

func getUserByEmail(ctx context.Context, db internal.Database, Email string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUserByEmailInTx(ctx, tx, Email)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func getUnscopedUserByEmailInTx(ctx context.Context, tx internal.Tx, email string) (internal.User, error) {
	var user internal.User
	err := tx.GetContext(ctx, &user, "SELECT * FROM users WHERE email=$1", email)
	if errors.Is(err, sql.ErrNoRows) {
		return internal.User{}, errors1.NewRecordNotFound(fmt.Sprintf("User.email=%s", email))
	}
	return user, err
}

func getUnscopedUserByEmail(ctx context.Context, db internal.Database, Email string) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := getUnscopedUserByEmailInTx(ctx, tx, Email)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func searchUsers(ctx context.Context, db internal.Database, where []WhereCondition, sort *OrderBy, limitOffset *LimitOffset) ([]internal.User, error) {
	i := 1
	args := []interface{}{}
	sql := fmt.Sprintf("SELECT id, created_at, deleted_at, username, email, password_hash, profile_url, email_verified, role FROM users")
	if len(where) > 0 {
		conditions := []string{}
		for _, c := range where {
			conditions = append(conditions, c.condition(i))
			args = append(args, c.arg())
			i++
		}
		sql += fmt.Sprintf(" WHERE %s", strings.Join(conditions, " AND "))
	}
	if sort != nil {
		sql += fmt.Sprintf(" ORDER BY %s %s", sort.Column, sort.Direction)
	}
	if limitOffset != nil {
		limitI := i
		offsetI := i + 1
		sql += fmt.Sprintf(" LIMIT $%d OFFSET $%d", limitI, offsetI)
		args = append(args, limitOffset.Limit)
		args = append(args, limitOffset.Offset)
		i += 2
	}
	rows, err := db.QueryxContext(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	results := []internal.User{}
	for rows.Next() {
		var row internal.User
		err = rows.StructScan(&row)
		if err != nil {
			return nil, err
		}
		results = append(results, row)
	}
	return results, nil
}

func insertUserInTx(ctx context.Context, tx internal.Tx, user internal.User) (internal.User, error) {
	newUser := user
	now := time.Now()
	newUser.CreatedAt = now
	newUser.DeletedAt = nil
	result, err := tx.ExecContext(
		ctx,
		"INSERT INTO users(id, created_at, deleted_at, username, email, password_hash, profile_url, email_verified, role) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)",
		newUser.ID, newUser.CreatedAt, newUser.DeletedAt, newUser.Username, newUser.Email, newUser.PasswordHash, newUser.ProfileURL, newUser.EmailVerified, newUser.Role,
	)
	if err != nil {
		return internal.User{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.User{}, err
	}
	if changedRows != 1 {
		return internal.User{}, fmt.Errorf("Inserted more than 1 row (%d)", changedRows)
	}
	return newUser, err
}

func insertUser(ctx context.Context, db internal.Database, user internal.User) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := insertUserInTx(ctx, tx, user)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func updateUserInTx(ctx context.Context, tx internal.Tx, inputUser internal.User) (internal.User, error) {
	updatedUser := inputUser
	result, err := tx.ExecContext(
		ctx,
		"UPDATE users SET created_at=$1, deleted_at=$2, username=$3, email=$4, password_hash=$5, profile_url=$6, email_verified=$7, role=$8 WHERE id = $9",
		updatedUser.CreatedAt, updatedUser.DeletedAt, updatedUser.Username, updatedUser.Email, updatedUser.PasswordHash, updatedUser.ProfileURL, updatedUser.EmailVerified, updatedUser.Role, updatedUser.ID,
	)
	if err != nil {
		return internal.User{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.User{}, err
	}
	if changedRows != 1 {
		return internal.User{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedUser, err
}

func updateUser(ctx context.Context, db internal.Database, user internal.User) (internal.User, error) {
	tx, err := db.BeginTxx(ctx, nil)
	if err != nil {
		return internal.User{}, err
	}
	defer tx.Rollback()

	result, err := updateUserInTx(ctx, tx, user)
	if err != nil {
		return internal.User{}, err
	}

	tx.Commit()
	return result, nil
}

func deleteUserInTx(ctx context.Context, tx internal.Tx, inputUser internal.User) (internal.User, error) {
	// Don't delete it if it's already deleted
	if inputUser.DeletedAt != nil {
		return inputUser, nil
	}

	updatedUser := inputUser
	now := time.Now()
	updatedUser.DeletedAt = &now
	result, err := tx.ExecContext(
		ctx,
		"UPDATE users SET created_at=$1, deleted_at=$2, username=$3, email=$4, password_hash=$5, profile_url=$6, email_verified=$7, role=$8 WHERE id = $9",
		updatedUser.CreatedAt, updatedUser.DeletedAt, updatedUser.Username, updatedUser.Email, updatedUser.PasswordHash, updatedUser.ProfileURL, updatedUser.EmailVerified, updatedUser.Role, updatedUser.ID,
	)
	if err != nil {
		return internal.User{}, err
	}
	changedRows, err := result.RowsAffected()
	if err != nil {
		return internal.User{}, err
	}
	if changedRows != 1 {
		return internal.User{}, fmt.Errorf("Updated more than 1 row (%d)", changedRows)
	}
	return updatedUser, err
}
