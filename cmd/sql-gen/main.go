// Generate all basic methods that perform database operations. This way they're consistent and can
// be easily updated

package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"

	"anime-skip.com/public-api/internal"
	. "github.com/dave/jennifer/jen"
	"github.com/ettle/strcase"
)

const (
	SQL_GEN_TAG = "sql_gen"
	PRIMARY_KEY = "primary_key"
	GET_ONE     = "get_one"
	GET_MANY    = "get_many"
	SOFT_DELETE = "soft_delete"
)

var models = []interface{}{
	internal.APIClient{},
	internal.EpisodeURL{},
	internal.Episode{},
	internal.Preferences{},
	internal.ShowAdmin{},
	internal.Show{},
	internal.TemplateTimestamp{},
	internal.Template{},
	internal.TimestampType{},
	internal.Timestamp{},
	internal.User{},
}

var internalPkg = "anime-skip.com/public-api/internal"
var asContextPkg = "anime-skip.com/public-api/internal/context"
var asErrorsPkg = "anime-skip.com/public-api/internal/errors"

// Ran in the postgres package folder
func main() {
	println("SQL Generation")

	filename := fmt.Sprintf("generated.go")
	file := NewFile("postgres")
	file.HeaderComment("Code generated by cmd/sqlgen/main.go, DO NOT EDIT.")

	println(" - Search Interfaces")
	generateSearchInterfaces(file)
	for _, model := range models {
		fmt.Printf(" - %s\n", reflect.TypeOf(model).Name())
		generateModelSqlMethods(file, model)
	}

	writeFile(filename, file)
}

type ModelDetails struct {
	softDelete     *reflect.StructField
	primaryKeys    []reflect.StructField
	getOneColumns  []reflect.StructField
	getManyColumns []reflect.StructField
}

func generateSearchInterfaces(file *File) {
	file.Comment("Search types")
	file.Line()

	file.Type().Id("WhereCondition").Interface(
		Id("condition").Call(Id("argNumber").Int()).String(),
		Id("arg").Call().Interface(),
	)
	file.Line()

	file.Type().Id("LimitOffset").Struct(
		Id("Limit").Int(),
		Id("Offset").Int(),
	)
	file.Line()

	file.Type().Id("OrderBy").Struct(
		Id("Column").String(),
		Id("Direction").String(),
	)
	file.Line()

	createBasicSearchCondition(file, "WhereGT", "interface{}", ">")
	createBasicSearchCondition(file, "WhereGTE", "interface{}", ">=")
	createBasicSearchCondition(file, "WhereLT", "interface{}", "<")
	createBasicSearchCondition(file, "WhereLTE", "interface{}", "<=")
	createBasicSearchCondition(file, "WhereEqual", "interface{}", "=")
	createLikeSearchCondition(file)
}

func generateModelSqlMethods(file *File, model interface{}) {
	modelType := reflect.TypeOf(model)
	modelDetails := getModelDetails(modelType)

	file.Comment(modelType.Name()).Line()

	if len(modelDetails.primaryKeys) == 1 {
		// Primary key is just a get one, but ignoreing deleted at
		hardDeleteGetOne(file, modelType, modelDetails.primaryKeys[0])
	} else if len(modelDetails.primaryKeys) > 1 {
		getCompoundPrimaryKey(file, modelType, modelDetails.primaryKeys)
	}

	for _, field := range modelDetails.getOneColumns {
		if modelDetails.softDelete != nil {
			softDeleteGetOneScoped(file, modelType, field, *modelDetails.softDelete)
			softDeleteGetOneUnscoped(file, modelType, field)
		} else {
			hardDeleteGetOne(file, modelType, field)
		}
	}

	for _, field := range modelDetails.getManyColumns {
		if modelDetails.softDelete != nil {
			softDeleteGetManyScoped(file, modelType, field, *modelDetails.softDelete)
			softDeleteGetManyUnscoped(file, modelType, field)
		} else {
			hardDeleteGetMany(file, modelType, field)
		}
	}

	search(file, modelType)

	insertInTx(file, modelType)
	insert(file, modelType)

	updateInTx(file, modelType, modelDetails)
	update(file, modelType)

	if len(modelDetails.primaryKeys) > 0 {
		if modelDetails.softDelete != nil {
			softDeleteInTx(file, modelType, modelDetails)
		} else {
			hardDeleteInTx(file, modelType, modelDetails.primaryKeys)
		}
	}
}

// Utils

func writeFile(filename string, generatedFile *File) {
	file, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer file.Close()
	file.WriteString(fmt.Sprintf("%#v", generatedFile))
}

func getModelDetails(model reflect.Type) ModelDetails {
	fields := getModelFields(model)
	getOneColumns := []reflect.StructField{}
	getManyColumns := []reflect.StructField{}
	primaryKeys := []reflect.StructField{}
	var softDelete *reflect.StructField
	for _, field := range fields {
		tag := field.Tag.Get(SQL_GEN_TAG)
		if strings.Contains(tag, PRIMARY_KEY) {
			primaryKeys = append(primaryKeys, field)
		}
		if strings.Contains(tag, GET_ONE) {
			getOneColumns = append(getOneColumns, field)
		}
		if strings.Contains(tag, GET_MANY) {
			getManyColumns = append(getManyColumns, field)
		}
		if strings.Contains(tag, SOFT_DELETE) {
			fieldCopy := field
			softDelete = &fieldCopy
		}
	}
	return ModelDetails{
		softDelete:     softDelete,
		primaryKeys:    primaryKeys,
		getOneColumns:  getOneColumns,
		getManyColumns: getManyColumns,
	}
}

func getModelFields(t reflect.Type) (fields []reflect.StructField) {
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.Type.Name() == reflect.TypeOf(internal.BaseEntity{}).Name() {
			baseFields := getModelFields(field.Type)
			for _, baseField := range baseFields {
				fields = append(fields, baseField)
			}
		} else {
			fields = append(fields, field)
		}
	}
	return
}

func getColumnName(field reflect.StructField) string {
	dbTag := field.Tag.Get("db")
	if dbTag != "" {
		return dbTag
	}
	return strcase.ToSnake(field.Name)
}

func pluralize(str string) string {
	if strings.HasSuffix(str, "s") {
		return str
	}
	return str + "s"
}

func getSqlColumns(model reflect.Type, excludePrimaryKeys bool) []string {
	fields := getModelFields(model)
	columns := []string{}
	for _, field := range fields {
		if !excludePrimaryKeys || !strings.Contains(field.Tag.Get(SQL_GEN_TAG), PRIMARY_KEY) {
			columns = append(columns, strcase.ToSnake(field.Name))
		}
	}
	return columns
}

func getSqlPlaceholders(model reflect.Type, excludePrimaryKeys bool) []string {
	fields := getModelFields(model)
	placeholders := []string{}
	i := 1
	for _, field := range fields {
		if !excludePrimaryKeys || !strings.Contains(field.Tag.Get(SQL_GEN_TAG), PRIMARY_KEY) {
			placeholders = append(placeholders, fmt.Sprintf("$%d", i))
			i++
		}
	}
	return placeholders
}

func getSqlParamValues(varName string, model reflect.Type, excludePrimaryKeys bool) []Code {
	fields := getModelFields(model)
	values := []Code{}
	for _, field := range fields {
		if !excludePrimaryKeys || !strings.Contains(field.Tag.Get(SQL_GEN_TAG), PRIMARY_KEY) {
			values = append(values, Id(varName).Dot(field.Name))
		}
	}
	return values
}

// Generated Types

func createBasicSearchCondition(file *File, name string, typeName string, condition string) {
	file.Type().Id(name).Struct(
		Id("column").String(),
		Id("value").Id(typeName),
	)

	file.Func().Params(
		Id("w").Id(name),
	).Id("condition").Params(
		Id("argNumber").Int(),
	).String().Block(
		Return().Qual("fmt", "Sprintf").Call(
			Lit("%s %s $%d"),
			Id("w").Dot("column"),
			Lit(condition),
			Id("argNumber"),
		),
	)

	file.Func().Params(
		Id("w").Id(name),
	).Id("arg").Params().Interface().Block(
		Return().Id("w").Dot("value"),
	)

	file.Line()
}

func createLikeSearchCondition(file *File) {
	file.Type().Id("WhereLike").Struct(
		Id("column").String(),
		Id("value").String(),
		Id("ignoreCase").Bool(),
	)

	file.Func().Params(
		Id("w").Id("WhereLike"),
	).Id("condition").Params(
		Id("argNumber").Int(),
	).String().Block(
		Id("like").Op(":=").Lit("LIKE"),
		If(Id("w").Dot("ignoreCase")).Block(
			Id("like").Op("=").Lit("ILIKE"),
		),
		Return().Qual("fmt", "Sprintf").Call(
			Lit("%s %s $%d"),
			Id("w").Dot("column"),
			Id("like"),
			Id("argNumber"),
		),
	)

	file.Func().Params(
		Id("w").Id("WhereLike"),
	).Id("arg").Params().Interface().Block(
		Return().Id("w").Dot("value"),
	)

	file.Line()
}

// Generated Functions

func unwrapInTxFunc(file *File, model reflect.Type, inTxFuncName string, argName string, argType reflect.Type, returnSlice bool) {
	modelName := model.Name()
	funcName := strings.Replace(inTxFuncName, "InTx", "", 1)
	resultName := "result"

	var emptyModel Code
	var returnType Code
	if returnSlice {
		returnType = Index().Qual(internalPkg, modelName)
		emptyModel = Nil()
	} else {
		returnType = Qual(internalPkg, modelName)
		emptyModel = Qual(internalPkg, modelName).Block()
	}
	ifErrReturn := If(Err().Op("!=").Nil()).Block(
		Return().List(emptyModel, Err()),
	)

	file.Func().Id(funcName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("db").Qual(internalPkg, "Database"),
		Id(argName).Qual(argType.PkgPath(), argType.Name()),
	).Params(
		returnType,
		Error(),
	).Block(
		List(Id("tx"), Err()).Op(":=").Id("db").Dot("BeginTxx").Call(Id("ctx"), Nil()),
		ifErrReturn,
		Defer().Id("tx").Dot("Rollback").Call(),
		Empty(),
		List(Id(resultName), Err()).Op(":=").Id(inTxFuncName).Call(Id("ctx"), Id("tx"), Id(argName)),
		ifErrReturn,
		Empty(),
		Id("tx").Dot("Commit").Call(),
		Return().List(Id(resultName), Nil()),
	).Line()
}

// Get One

func _getOne(file *File, funcName string, sql string, model reflect.Type, field reflect.StructField) {
	modelName := model.Name()
	inTxFuncName := funcName + "InTx"
	varName := strcase.ToGoCamel(modelName)
	fieldName := strcase.ToGoCamel(field.Name)
	errMessage := fmt.Sprintf("%s.%s=", modelName, fieldName) + "%s"

	file.Func().Id(inTxFuncName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("tx").Qual(internalPkg, "Tx"),
		Id(fieldName).Qual(field.Type.PkgPath(), field.Type.Name()),
	).Params(
		Qual(internalPkg, modelName),
		Error(),
	).Block(
		Var().Id(varName).Qual(internalPkg, modelName),
		Err().Op(":=").Id("tx").Dot("GetContext").Call(
			Id("ctx"),
			Op("&").Id(varName),
			Lit(sql),
			Id(fieldName),
		),
		If(Qual("errors", "Is").Call(Err(), Qual("database/sql", "ErrNoRows"))).Block(
			Return(
				Qual(internalPkg, modelName).Block(),
				Qual(asErrorsPkg, "NewRecordNotFound").Call(
					Qual("fmt", "Sprintf").Call(Lit(errMessage), Id(fieldName)),
				),
			),
		),
		Return(
			Id(varName),
			Err(),
		),
	).Line()

	unwrapInTxFunc(file, model, inTxFuncName, field.Name, field.Type, false)
}

func _getOneNoSoftDelete(file *File, funcName string, model reflect.Type, field reflect.StructField) {
	modelName := model.Name()
	columnName := getColumnName(field)
	tableName := pluralize(strcase.ToSnake(modelName))
	sql := fmt.Sprintf(`SELECT * FROM %s WHERE %s=$1`, tableName, columnName)
	_getOne(file, funcName, sql, model, field)
}

func getCompoundPrimaryKey(file *File, model reflect.Type, primaryKeys []reflect.StructField) {
	modelName := model.Name()
	funcNameInTx := fmt.Sprintf("get%sInTx", modelName)
	varName := strcase.ToGoCamel(modelName)
	tableName := pluralize(strcase.ToSnake(modelName))

	sqlWheres := []string{}
	for i, field := range primaryKeys {
		sqlWheres = append(sqlWheres, fmt.Sprintf("%s=$%d", getColumnName(field), i+1))
	}
	sql := fmt.Sprintf("SELECT * FROM %s WHERE %s", tableName, strings.Join(sqlWheres, " AND "))

	args := []Code{
		Id("ctx").Qual("context", "Context"),
		Id("tx").Qual(internalPkg, "Tx"),
	}
	sqlParams := []Code{
		Id("ctx"),
		Op("&").Id(varName),
		Lit(sql),
	}
	errMessages := []string{}
	for _, field := range primaryKeys {
		fieldName := strcase.ToGoCamel(field.Name)
		args = append(args, Id(fieldName).Qual(field.Type.PkgPath(), field.Type.Name()))
		sqlParams = append(sqlParams, Id(fieldName))
		errMessages = append(errMessages, fmt.Sprintf("%s.%s=", modelName, fieldName)+"%s")
	}
	errMessage := strings.Join(errMessages, " and ")

	sprintfArgs := []Code{Lit(errMessage)}
	for _, field := range primaryKeys {
		fieldName := strcase.ToGoCamel(field.Name)
		sprintfArgs = append(sprintfArgs, Id(fieldName))
	}

	file.Func().Id(funcNameInTx).Params(args...).Params(
		Qual(internalPkg, modelName),
		Error(),
	).Block(
		Var().Id(varName).Qual(internalPkg, modelName),
		Err().Op(":=").Id("tx").Dot("GetContext").Call(sqlParams...),
		If(Qual("errors", "Is").Call(Err(), Qual("database/sql", "ErrNoRows"))).Block(
			Return(
				Qual(internalPkg, modelName).Block(),
				Qual(asErrorsPkg, "NewRecordNotFound").Call(
					Qual("fmt", "Sprintf").Call(sprintfArgs...),
				),
			),
		),
		Return(
			Id(varName),
			Err(),
		),
	).Line()
}

func hardDeleteGetOne(file *File, model reflect.Type, field reflect.StructField) {
	funcName := fmt.Sprintf("get%sBy%s", model.Name(), strcase.ToGoPascal(field.Name))
	_getOneNoSoftDelete(file, funcName, model, field)
}

func softDeleteGetOneUnscoped(file *File, model reflect.Type, field reflect.StructField) {
	funcName := fmt.Sprintf("getUnscoped%sBy%s", model.Name(), strcase.ToGoPascal(field.Name))
	_getOneNoSoftDelete(file, funcName, model, field)
}

func softDeleteGetOneScoped(
	file *File,
	model reflect.Type,
	field reflect.StructField,
	softDeleteField reflect.StructField,
) {
	modelName := model.Name()
	columnName := getColumnName(field)
	softDeleteColumnName := getColumnName(softDeleteField)
	funcName := fmt.Sprintf("get%sBy%s", modelName, strcase.ToGoPascal(field.Name))
	tableName := pluralize(strcase.ToSnake(modelName))
	sql := fmt.Sprintf(
		`SELECT * FROM %s WHERE %s=$1 AND %s IS NULL`,
		tableName,
		columnName,
		softDeleteColumnName,
	)

	_getOne(file, funcName, sql, model, field)
}

// Get Many

func _getMany(file *File, funcName string, sql string, model reflect.Type, field reflect.StructField) {
	modelName := model.Name()
	itemName := strcase.ToGoCamel(modelName)
	varName := pluralize(itemName)
	fieldName := strcase.ToGoCamel(field.Name)
	internalQual := model.PkgPath()
	returnErr := If(Err().Op("!=").Nil()).Block(
		Return().List(Nil(), Err()),
	)
	inTxFuncName := funcName + "InTx"

	file.Func().Id(inTxFuncName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("tx").Qual(internalQual, "Tx"),
		Id(fieldName).Qual(field.Type.PkgPath(), field.Type.Name()),
	).Params(
		Index().Qual(internalQual, modelName),
		Error(),
	).Block(
		List(Id("rows"), Err()).Op(":=").Id("tx").Dot("QueryxContext").Call(Id("ctx"), Lit(sql)),
		returnErr,
		Defer().Id("rows").Dot("Close").Call(),
		Line(),

		Id(varName).Op(":=").Index().Qual(internalQual, modelName).Values(),
		For(Id("rows").Dot("Next").Call()).Block(
			Var().Id(itemName).Qual(internalQual, modelName),
			Err().Op("=").Id("rows").Dot("StructScan").Call(Op("&").Id(itemName)),
			returnErr,
			Id(varName).Op("=").Append(Id(varName), Id(itemName)),
		),
		Return(
			Id(varName),
			Nil(),
		),
	).Line()

	unwrapInTxFunc(file, model, inTxFuncName, field.Name, field.Type, true)
}

func _getManyIgnoreSoftDelete(file *File, funcName string, model reflect.Type, field reflect.StructField) {
	modelName := model.Name()
	tableName := pluralize(strcase.ToSnake(modelName))
	sql := fmt.Sprintf(`SELECT * FROM %s`, tableName)

	_getMany(file, funcName, sql, model, field)
}

func hardDeleteGetMany(file *File, model reflect.Type, field reflect.StructField) {
	funcName := fmt.Sprintf("get%sBy%s", pluralize(model.Name()), strcase.ToGoPascal(field.Name))

	_getManyIgnoreSoftDelete(file, funcName, model, field)
}

func softDeleteGetManyUnscoped(file *File, model reflect.Type, field reflect.StructField) {
	funcName := fmt.Sprintf("getUnscoped%sBy%s", pluralize(model.Name()), strcase.ToGoPascal(field.Name))

	_getManyIgnoreSoftDelete(file, funcName, model, field)
}

func softDeleteGetManyScoped(
	file *File,
	model reflect.Type,
	field reflect.StructField,
	softDeleteField reflect.StructField,
) {
	modelName := model.Name()
	funcName := fmt.Sprintf("get%sBy%s", pluralize(modelName), strcase.ToGoPascal(field.Name))
	tableName := pluralize(strcase.ToSnake(modelName))
	sql := fmt.Sprintf(
		`SELECT * FROM %s WHERE %s IS NULL`,
		tableName,
		strcase.ToSnake(softDeleteField.Name),
	)

	_getMany(file, funcName, sql, model, field)
}

// Search

func search(file *File, model reflect.Type) {
	modelName := model.Name()
	funcName := fmt.Sprintf("search%s", pluralize(modelName))
	tableName := pluralize(strcase.ToSnake(modelName))
	fields := getModelFields(model)
	returnErr := If(Err().Op("!=").Nil()).Block(
		Return().List(Nil(), Err()),
	)
	selects := []string{}
	for _, field := range fields {
		selects = append(selects, getColumnName(field))
	}

	file.Func().Id(funcName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("db").Qual(internalPkg, "Database"),
		Id("where").Index().Id("WhereCondition"),
		Id("sort").Id("*OrderBy"),
		Id("limitOffset").Id("*LimitOffset"),
	).Params(Index().Qual(internalPkg, modelName), Error()).Block(
		Id("i").Op(":=").Lit(1),
		Id("args").Op(":=").Index().Interface().Block(),
		Id("sql").Op(":=").Qual("fmt", "Sprintf").Call(
			Lit(fmt.Sprintf("SELECT %s FROM %s", strings.Join(selects, ", "), tableName)),
		),
		If(Len(Id("where")).Op(">").Lit(0)).Block(
			Id("conditions").Op(":=").Index().String().Block(),
			For(
				List(Id("_"), Id("c")).Op(":=").Range().Id("where"),
			).Block(
				Id("conditions").Op("=").Append(Id("conditions"), Id("c").Dot("condition").Call(Id("i"))),
				Id("args").Op("=").Append(Id("args"), Id("c").Dot("arg").Call()),
				Id("i").Op("++"),
			),
			Id("sql").Op("+=").Qual("fmt", "Sprintf").Call(
				Lit(" WHERE %s"),
				Qual("strings", "Join").Call(Id("conditions"), Lit(" AND ")),
			),
		),
		If(Id("sort").Op("!=").Nil()).Block(
			Id("sql").Op("+=").Qual("fmt", "Sprintf").Call(
				Lit(" ORDER BY %s %s"),
				Id("sort").Dot("Column"),
				Id("sort").Dot("Direction"),
			),
		),
		If(Id("limitOffset").Op("!=").Nil()).Block(
			Id("limitI").Op(":=").Id("i"),
			Id("offsetI").Op(":=").Id("i").Op("+").Lit(1),
			Id("sql").Op("+=").Qual("fmt", "Sprintf").Call(
				Lit(" LIMIT $%d OFFSET $%d"),
				Id("limitI"),
				Id("offsetI"),
			),
			Id("args").Op("=").Append(Id("args"), Id("limitOffset").Dot("Limit")),
			Id("args").Op("=").Append(Id("args"), Id("limitOffset").Dot("Offset")),
			Id("i").Op("+=").Lit(2),
		),

		List(Id("rows"), Err()).Op(":=").Id("db").Dot("QueryxContext").Call(Id("ctx"), Id("sql"), Id("args").Op("...")),
		returnErr,
		Defer().Id("rows").Dot("Close").Call(),
		Line(),

		Id("results").Op(":=").Index().Qual(internalPkg, modelName).Values(),
		For(Id("rows").Dot("Next").Call()).Block(
			Var().Id("row").Qual(internalPkg, modelName),
			Err().Op("=").Id("rows").Dot("StructScan").Call(Op("&").Id("row")),
			returnErr,
			Id("results").Op("=").Append(Id("results"), Id("row")),
		),
		Return(
			Id("results"),
			Nil(),
		),
	).Line()
}

// Insert

func updateMetadataTime(id string, timeFieldName string) *Statement {
	return Id(id).Dot(timeFieldName).Op("=").Id("now")
}
func updateMetadataUserID(id string, userIDFieldName string) *Statement {
	return Id(id).Dot(userIDFieldName).Op("=").Id("claims").Dot("UserID")
}
func updateToNil(id string, nilFieldName string) *Statement {
	return Id(id).Dot(nilFieldName).Op("=").Nil()
}

func insertInTx(file *File, model reflect.Type) {
	modelName := model.Name()
	funcName := fmt.Sprintf("insert%sInTx", modelName)
	argName := strcase.ToGoCamel(modelName)
	newModelName := strcase.ToGoCamel("new" + modelName)
	tableName := pluralize(strcase.ToSnake(modelName))
	columns := getSqlColumns(model, false)
	placeholders := getSqlPlaceholders(model, false)
	paramValues := getSqlParamValues(newModelName, model, false)
	sql := fmt.Sprintf(
		"INSERT INTO %s(%s) VALUES (%s)",
		tableName,
		strings.Join(columns, ", "),
		strings.Join(placeholders, ", "),
	)
	execParams := []Code{Line().Id("ctx"), Line().Lit(sql)}
	execParams = append(execParams, Line().List(paramValues...))
	execParams = append(execParams, Line())
	emptyModel := Qual(internalPkg, modelName).Block()
	ifErrReturn := If(Err().Op("!=").Nil()).Block(
		Return().List(emptyModel, Err()),
	)
	_, hasCreatedAt := model.FieldByName("CreatedAt")
	_, hasCreatedBy := model.FieldByName("CreatedByUserID")
	_, hasUpdatedAt := model.FieldByName("UpdatedAt")
	_, hasUpdatedBy := model.FieldByName("UpdatedByUserID")
	_, hasDeletedAt := model.FieldByName("DeletedAt")
	_, hasDeletedBy := model.FieldByName("DeletedByUserID")

	file.Func().Id(funcName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("tx").Qual(internalPkg, "Tx"),
		Id(argName).Qual(internalPkg, modelName),
	).Params(
		Qual(internalPkg, modelName),
		Error(),
	).BlockFunc(func(g *Group) {
		g.Id(newModelName).Op(":=").Id(argName)
		if hasCreatedBy || hasUpdatedBy {
			g.List(Id("claims"), Err()).Op(":=").Qual(asContextPkg, "GetAuthClaims").Call(Id("ctx"))
			g.Add(ifErrReturn)
		}
		if hasCreatedAt || hasUpdatedAt {
			g.Id("now").Op(":=").Qual("time", "Now").Call()
		}
		if hasCreatedAt {
			g.Add(updateMetadataTime(newModelName, "CreatedAt"))
		}
		if hasCreatedBy {
			g.Add(updateMetadataUserID(newModelName, "CreatedByUserID"))
		}
		if hasUpdatedAt {
			g.Add(updateMetadataTime(newModelName, "UpdatedAt"))
		}
		if hasUpdatedBy {
			g.Add(updateMetadataUserID(newModelName, "UpdatedByUserID"))
		}
		if hasDeletedAt {
			g.Add(updateToNil(newModelName, "DeletedAt"))
		}
		if hasDeletedBy {
			g.Add(updateToNil(newModelName, "DeletedByUserID"))
		}
		g.List(Id("result"), Err()).Op(":=").Id("tx").Dot("ExecContext").Call(execParams...)
		g.Add(ifErrReturn)
		g.List(Id("changedRows"), Err()).Op(":=").Id("result").Dot("RowsAffected").Call()
		g.Add(ifErrReturn)
		g.If(Id("changedRows").Op("!=").Lit(1)).Block(
			Return().List(emptyModel, Qual("fmt", "Errorf").Call(Lit("Inserted more than 1 row (%d)"), Id("changedRows"))),
		)
		g.Return().List(Id(newModelName), Err())
	}).Line()
}

func insert(file *File, model reflect.Type) {
	inTxFuncName := fmt.Sprintf("insert%sInTx", model.Name())
	unwrapInTxFunc(file, model, inTxFuncName, strcase.ToGoCamel(model.Name()), model, false)
}

// Update

func _updateInTx(file *File, model reflect.Type, details ModelDetails, funcName string, deleting bool) {
	modelName := model.Name()
	argName := strcase.ToGoCamel("input" + modelName)
	updatedModelName := strcase.ToGoCamel("updated" + modelName)
	tableName := pluralize(strcase.ToSnake(modelName))
	columns := getSqlColumns(model, true)
	if len(columns) == 0 {
		return
	}
	placeholders := getSqlPlaceholders(model, true)
	sqlSets := []string{}
	for i := 0; i < len(columns); i++ {
		sqlSets = append(sqlSets, fmt.Sprintf("%s=%s", columns[i], placeholders[i]))
	}
	paramValues := getSqlParamValues(updatedModelName, model, true)
	sql := fmt.Sprintf(
		"UPDATE %s SET %s WHERE %s = $%d",
		tableName,
		strings.Join(sqlSets, ", "),
		getColumnName(details.primaryKeys[0]),
		len(sqlSets)+1,
	)
	execParams := []Code{Line().Id("ctx"), Line().Lit(sql)}
	execParams = append(execParams, Line().List(paramValues...))
	execParams = append(execParams, Id(updatedModelName).Dot(details.primaryKeys[0].Name))
	execParams = append(execParams, Line())
	emptyModel := Qual(internalPkg, modelName).Block()
	ifErrReturn := If(Err().Op("!=").Nil()).Block(
		Return().List(emptyModel, Err()),
	)
	_, hasUpdatedAt := model.FieldByName("UpdatedAt")
	_, hasUpdatedBy := model.FieldByName("UpdatedByUserID")
	_, hasDeletedAt := model.FieldByName("DeletedAt")
	_, hasDeletedBy := model.FieldByName("DeletedByUserID")
	hasDeletedAt = deleting && hasDeletedAt
	hasDeletedBy = deleting && hasDeletedBy

	file.Func().Id(funcName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("tx").Qual(internalPkg, "Tx"),
		Id(argName).Qual(internalPkg, modelName),
	).Params(
		Qual(internalPkg, modelName),
		Error(),
	).BlockFunc(func(g *Group) {
		if deleting {
			g.Add(Comment("Don't delete it if it's already deleted"))
			var ifCase = Id(argName).Dot("DeletedAt").Op("!=").Nil()
			if hasDeletedBy {
				ifCase = ifCase.Op("&&").Id(argName).Dot("DeletedByUserID").Op("!=").Nil()
			}
			g.If(ifCase).Block(
				Return().List(Id(argName), Nil()),
			).Line()
		}
		g.Id(updatedModelName).Op(":=").Id(argName)
		if hasUpdatedBy || hasDeletedBy {
			g.List(Id("claims"), Err()).Op(":=").Qual(asContextPkg, "GetAuthClaims").Call(Id("ctx"))
			g.Add(ifErrReturn)
		}
		if hasUpdatedAt || hasDeletedAt {
			g.Id("now").Op(":=").Qual("time", "Now").Call()
		}
		if hasUpdatedAt {
			g.Add(updateMetadataTime(updatedModelName, "UpdatedAt"))
		}
		if hasUpdatedBy {
			g.Add(updateMetadataUserID(updatedModelName, "UpdatedByUserID"))
		}
		if hasDeletedAt {
			g.Add(Id(updatedModelName).Dot("DeletedAt").Op("=").Op("&").Id("now"))
		}
		if hasDeletedBy {
			g.Id(updatedModelName).Dot("DeletedByUserID").Op("=").Op("&").Id("claims").Dot("UserID")
		}
		g.List(Id("result"), Err()).Op(":=").Id("tx").Dot("ExecContext").Call(execParams...)
		g.Add(ifErrReturn)
		g.List(Id("changedRows"), Err()).Op(":=").Id("result").Dot("RowsAffected").Call()
		g.Add(ifErrReturn)
		g.If(Id("changedRows").Op("!=").Lit(1)).Block(
			Return().List(emptyModel, Qual("fmt", "Errorf").Call(Lit("Updated more than 1 row (%d)"), Id("changedRows"))),
		)
		g.Return().List(Id(updatedModelName), Err())
	}).Line()
}

func updateInTx(file *File, model reflect.Type, details ModelDetails) {
	funcName := fmt.Sprintf("update%sInTx", model.Name())
	_updateInTx(file, model, details, funcName, false)
}

func update(file *File, model reflect.Type) {
	inTxFuncName := fmt.Sprintf("update%sInTx", model.Name())
	columns := getSqlColumns(model, true)
	if len(columns) == 0 {
		return
	}
	unwrapInTxFunc(file, model, inTxFuncName, strcase.ToGoCamel(model.Name()), model, false)
}

// Delete

func hardDeleteInTx(file *File, model reflect.Type, primaryKeys []reflect.StructField) {
	modelName := model.Name()
	funcName := fmt.Sprintf("delete%sInTx", modelName)
	argName := strcase.ToGoCamel(modelName)
	tableName := pluralize(strcase.ToSnake(modelName))
	sqlWheres := []string{}
	for index, primaryKey := range primaryKeys {
		sqlWheres = append(sqlWheres, fmt.Sprintf("%s=$%d", getColumnName(primaryKey), index+1))
	}
	sql := fmt.Sprintf(
		"DELETE FROM %s WHERE %s",
		tableName,
		strings.Join(sqlWheres, " AND "),
	)
	execArgs := []Code{Id("ctx"), Lit(sql)}
	for _, primaryKey := range primaryKeys {
		execArgs = append(execArgs, Id(argName).Dot(primaryKey.Name))
	}
	ifErrReturn := If(Err().Op("!=").Nil()).Block(
		Return().Err(),
	)

	file.Commentf(
		"Hard delete the %s. It requires the entire model be passed in so that you have it before calling this function, and can return the value if needed",
		modelName,
	).Line().Func().Id(funcName).Params(
		Id("ctx").Qual("context", "Context"),
		Id("tx").Qual(internalPkg, "Tx"),
		Id(argName).Qual(internalPkg, modelName),
	).Error().BlockFunc(func(g *Group) {
		g.List(Id("result"), Err()).Op(":=").Id("tx").Dot("ExecContext").Call(execArgs...)
		g.Add(ifErrReturn)
		g.List(Id("changedRows"), Err()).Op(":=").Id("result").Dot("RowsAffected").Call()
		g.Add(ifErrReturn)
		g.If(Id("changedRows").Op("!=").Lit(1)).Block(
			Return().Qual("fmt", "Errorf").Call(Lit("Deleted more than 1 row (%d)"), Id("changedRows")),
		)
		g.Return().Err()
	}).Line()
}

func softDeleteInTx(file *File, model reflect.Type, details ModelDetails) {
	funcName := fmt.Sprintf("delete%sInTx", model.Name())
	_updateInTx(file, model, details, funcName, true)
}
